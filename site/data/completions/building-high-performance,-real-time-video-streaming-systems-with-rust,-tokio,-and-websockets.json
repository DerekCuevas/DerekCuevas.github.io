{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\", \"Securely Storing Secrets in Rust\", \"How to Write High Performance Elm Code with the Help of Web Workers\", \"The Ultimate Guide to Building and Optimizing GraphQL APIs with Node.js\", \"Building High-Performance Reactive Applications with Rust and Tokio\", \"Mastering GraphQL's Execution Phase with Node.js, TypeScript, and TypeGraphQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader. Ensure that the topic is not related to a previous post. Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Explain information and details in the post step by step."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7KhIB7xtIn3HoYGtwPruKHVDy6uqk",
  "object": "chat.completion",
  "created": 1685167331,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 810,
   "completion_tokens": 1348,
   "total_tokens": 2158
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\n\nTags: Rust, Tokio, WebSockets\n\nReal-time video streaming systems require highly reliable and fast communication between clients and servers, and Rust and Tokio are two technologies that offer the necessary performance to build such systems. In this post, we will explore how to build a high-performance, real-time video streaming system with Rust, Tokio, and WebSockets.\n\n## Setting up the project\n\nFirst, let's create a new Rust project and add the dependencies we'll need.\n\n```bash\n$ cargo new video_streaming\n$ cd video_streaming\n```\n\nAdd the following dependencies to your `Cargo.toml` file:\n\n```toml\n[dependencies]\ntokio = { version = \"1.1\", features = [\"full\"] }\nwebsocket = \"0.23.1\"\n```\n\nWe will use the `tokio` library for asynchronous I/O operations, and the `websocket` library for real-time communication with clients.\n\n## Implementing the server\n\nNow we can implement the server. In a new file named `server.rs`, add the following code:\n\n```rust\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse tokio::sync::{mpsc, Mutex};\nuse tokio::time::{interval_at, Duration, Instant};\nuse tokio::net::TcpListener;\nuse tokio::stream::StreamExt;\n\nuse websocket::{OwnedMessage, WebSocket};\nuse websocket::server::InvalidConnection;\n\n#[tokio::main]\nasync fn main() {\n    let addr = \"127.0.0.1:8080\";\n\n    let listener = TcpListener::bind(addr).await.unwrap();\n    println!(\"Listening on: {}\", addr);\n\n    let state = Arc::new(Mutex::new(State {\n        clients: HashMap::new(),\n        video_data: vec![],\n        frame_rate: 30,\n    }));\n\n    let state1 = state.clone();\n    let (tx, mut rx) = mpsc::channel(1024);\n\n    tokio::spawn(async move {\n        let mut interval = interval_at(Instant::now(), Duration::from_millis(33));\n        loop {\n            interval.tick().await;\n            let frame_duration = Duration::from_secs(1) / state1.lock().await.frame_rate as u32;\n            let mut state = state1.lock().await;\n\n            while state.video_data.len() > (state.frame_rate * 5) as usize {\n                state.video_data.remove(0);\n            }\n\n            let frame = state.video_data.pop();\n\n            if let Some(frame) = frame {\n                let message = OwnedMessage::Binary(frame);\n                for tx in state.clients.values() {\n                    if let Err(e) = tx.send(message.clone()).await {\n                        println!(\"Error sending message: {}\", e);\n                    }\n                }\n            }\n\n            state.frame_rate = rx.try_recv().unwrap_or(state.frame_rate);\n        }\n    });\n\n    while let Ok((stream, addr)) = listener.accept().await {\n        let state = state.clone();\n        tokio::spawn(async move {\n            if let Err(e) = handle_connection(stream, addr, state).await {\n                println!(\"Error: {}\", e);\n            }\n        });\n    }\n}\n\nasync fn handle_connection(stream: tokio::net::TcpStream, addr: std::net::SocketAddr, state: Arc<Mutex<State>>) -> Result<(), InvalidConnection> {\n    let ws = WebSocket::new(stream);\n    let (mut socket, mut sender) = ws.accept().await?;\n\n    println!(\"Connected client: {}\", addr);\n\n    let (tx, mut rx) = mpsc::channel(1024);\n    let client_id = addr.to_string();\n    state.lock().await.clients.insert(client_id.clone(), tx);\n\n    while let Some(Ok(message)) = socket.next().await {\n        match message {\n            OwnedMessage::Binary(data) => {\n                state.lock().await.video_data.push(data);\n            }\n            OwnedMessage::Close(_) => {\n                break;\n            }\n            _ => {}\n        }\n    }\n\n    state.lock().await.clients.remove(&client_id);\n    Ok(())\n}\n\n#[derive(Debug)]\nstruct State {\n    clients: HashMap<String, mpsc::Sender<OwnedMessage>>,\n    video_data: Vec<Vec<u8>>,\n    frame_rate: u32,\n}\n```\n\nThe server uses `tokio::net::TcpListener` to listen for incoming connections on Port 8080. It obtains a lock on the server `State`, which holds information about the connected clients, the video data, and the frame rate. The server then spawns a Tokio task to stream video data to clients. It accepts connections in a loop and handles them using the `handle_connection` function. The `handle_connection` function receives messages from the client and adds them to the video data buffer. When a client disconnects, it removes it from the clients list.\n\n## Implementing the client\n\nNow let's implement a Rust client that connects to the server and streams video data. In a new file named `client.rs`, add the following code:\n\n```rust\nuse std::io::{self, Read};\nuse std::net::TcpStream;\nuse std::thread;\n\nuse websocket::{OwnedMessage, WebSocket};\n\nfn main() -> io::Result<()> {\n    let args: Vec<String> = std::env::args().collect();\n    let addr = &args[1];\n\n    let mut stream = TcpStream::connect(addr)?;\n    stream.set_nonblocking(true)?;\n\n    let mut ws = WebSocket::new(stream);\n    ws.connect().unwrap();\n\n    loop {\n        let mut buf = vec![0u8; 4096];\n        match ws.recv_message() {\n            Ok(OwnedMessage::Binary(data)) => {\n                // Process video data\n            }\n            Ok(m) => println!(\"Received: {:?}\", m),\n            Err(e) => {\n                println!(\"Error: {}\", e);\n                break;\n            }\n        }\n    }\n\n    Ok(())\n}\n```\n\nThe client connects to the server and uses a loop to receive binary data messages from the server. The binary data represents video frames, which can be processed by the client to display the video stream.\n\n## Conclusion\n\nIn this post, we built a high-performance, real-time video streaming system using Rust, Tokio, and WebSockets. The server handles incoming connections and streams video data to clients, while the client connects to the server and displays the video stream. With Rust and Tokio, we can create fast and reliable real-time video streaming systems."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}