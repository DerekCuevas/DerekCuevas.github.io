{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\", \"The Magic of High-Level Streams\", \"Using Rust's Pinning API for Safe and Performant Async Programming\", \"Building Scalable REST APIs with Node.js and PostgreSQL\", \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7N92qh0STnxloqIyO1hqeCwfHdrml",
  "object": "chat.completion",
  "created": 1685750668,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 799,
   "completion_tokens": 1005,
   "total_tokens": 1804
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building Composable, Scalable, and Reusable Redux Reducers\n\nTags: Redux, React, JavaScript\n\n## Introduction\n\nRedux, the popular state management library for React applications, is famous for its unidirectional data flow, immutable state, and predictable updates. One of the core concepts of Redux is a reducer, a pure function that receives the current state and an action, and returns the next state. A reducer is standalone, testable, and composable, which makes it a perfect tool for managing complex application states.\n\nHowever, building reducers is not always a trivial task. As applications grow, so does the complexity of states and interactions between them. Reducers can become entangled, monolithic, and hard to test. In this post, we will explore how to build composable, scalable, and reusable reducers that make managing states in complex applications a breeze.\n\n## What Makes a Good Reducer?\n\nA good reducer should have the following properties:\n\n- **Pure:** A reducer should not modify the current state or any of its arguments. It should always return a new state object.\n- **Deterministic:** A reducer should always return the same result given the same input. It should not have any side effects, such as changing the network, or reading from the DOM.\n- **Composable:** A reducer should be standalone and testable, but it should also be easy to compose with other reducers to form a larger reducer that manages a more complex state.\n- **Scalable:** A reducer should be able to handle a large number of states and interactions between them without becoming too complex or unmanageable.\n- **Reusable:** A reducer should be reusable in different parts of the application, or in different applications.\n\n## Composition Patterns\n\nThere are several composition patterns for reducers that make it easy to compose them into larger reducers. We will explore three of them:\n\n### Splitting Reduction Logic into Multiple Functions\n\nSplitting up the reduction logic into several functions that handle different parts of the state is a simple way to compose reducers. Each function is responsible for reducing a specific substate, and the final reducer combines all of them to form the complete state.\n\n```javascript\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ];\n    case 'TOGGLE_TODO':\n      return state.map(todo =>\n        todo.id === action.id ? { ...todo, completed: !todo.completed } : todo\n      );\n    default:\n      return state;\n  }\n}\n\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter;\n    default:\n      return state;\n  }\n}\n\nfunction todosApp(state = {}, action) {\n  return {\n    todos: todos(state.todos, action),\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action)\n  };\n}\n```\n\nIn this example, the todos reducer handles the todos substate, the visibilityFilter reducer handles the visibilityFilter substate, and the todosApp reducer combines them both into a single root reducer that can be passed to the Redux createStore function.\n\n### Using Higher-Order Reducers\n\nHigher-order reducers are reducers that take one or more reducers as arguments and return a new reducer. They are useful for adding common functionality, such as logging, to multiple reducers.\n\n```javascript\nfunction withLogging(reducer) {\n  return (state, action) => {\n    console.log(`Action ${action.type} was dispatched with state`, state);\n    const newState = reducer(state, action);\n    console.log(`Action resulted in state`, newState);\n    return newState;\n  };\n}\n```\n\nIn this example, withLogging is a higher-order reducer that takes a reducer as an argument and returns a new reducer that logs the current state and the resulting state for each dispatched action.\n\n### Using combineReducers\n\nThe combineReducers utility function provided by Redux is a simple way to combine multiple reducers into a single root reducer. It takes an object whose values are reducers, and returns a new reducer that maps the corresponding keys to the result of invoking the reducers with their respective state slices.\n\n```javascript\nimport { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n  todos: todosReducer,\n  visibilityFilter: visibilityFilterReducer\n});\n```\n\nIn this example, todosReducer and visibilityFilterReducer are reducers that handle the todos and visibilityFilter substates, respectively. The combineReducers function returns a new root reducer that can be passed to createStore.\n\n## Conclusion\n\nBuilding composable, scalable, and reusable reducers is essential for managing complex application states. By splitting up reduction logic into multiple functions, using higher-order reducers, and combining reducers using combineReducers, we can achieve reducers that are easier to test, maintain, and extend. Remember to keep reducers pure, deterministic, and easy to compose."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}