{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Use Kafka to Build Scalable and Fault-Tolerant Distributed Systems\", \"Advanced Techniques for Using PostgreSQL JSONB Data Type\", \"Writing Secure Rust Code: A Deep Dive into Memory Safety\", \"Fine-tuning BERT for Question Answering - A Step-by-Step Guide\", \"How to Use the Decorator Pattern for Flexible and Extensible Code\", \"A Deep Dive into Multithreading with Clojure\", \"How to Design Reactive Microservices Using Event-Driven Architecture\", \"Writing Efficient SQL Queries: Tips and Tricks\", \"Mastering Connection Pooling in Django\", \"Mastering the Actor Model Concurrency Paradigm in Elixir\", \"How to use Elm to build maintainable, efficient, and bug-free front-end applications\", \"How to Use Generators to Create Infinite Sequences in Python\", \"Building High Performance Distributed Data Pipelines with Apache Flink\", \"Implementing a Consistent Hashing Algorithm in TypeScript\", \"The Event Sourcing Design Pattern in TypeScript\", \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7PlxGKMuBRZnrcVtOW2BplPoZj5lB",
  "object": "chat.completion",
  "created": 1686376894,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 830,
   "completion_tokens": 1033,
   "total_tokens": 1863
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Building a High-Performance HTTP Proxy with Nginx\n\nTags: nginx, web server, HTTP proxy\n\nIn today's digital world, web servers form the backbone of most of the internet services around us. While there are numerous web servers available, Nginx has evolved to become one of the most popular servers in the industry. Its lightweight design, high concurrency support, low resource utilization, and extensible architecture make it the preferred choice for many developers and system administrators.\n\nIn this article, we will explore how to use Nginx as a high-performance HTTP proxy. We will cover the basics of HTTP proxying and examine the options available to Nginx that allow it to be used as a proxy server. We will also delve into the configuration of Nginx as a reverse proxy and load balancer.\n\n## Understanding HTTP Proxying\n\nHTTP proxying is the act of forwarding HTTP requests and responses between clients and servers to ensure secure and reliable communication. HTTP proxies are often used to protect the privacy of clients by hiding their IP addresses and to provide caching, content filtering, and load balancing capabilities.\n\nA typical HTTP proxy works by accepting connections from clients, and forwarding them to the server. A proxy server then receives the response from the server, and returns it to the client. This way, the client and server are not directly communicating with each other, but instead, they are communicating with the proxy.\n\n## Configuring Nginx as a HTTP Proxy\n\nTo configure Nginx as an HTTP proxy, the `proxy_pass` directive is used. This feature directs Nginx to forward requests to a specified server and return the responses to the client. Here's an example of how to set up `proxy_pass`:\n\n```\nlocation /api/ {\n    proxy_pass http://backend-server:8080/;\n}\n```\n\nThis configuration will tell Nginx to redirect all requests to the `/api/*` endpoint to the server running at `http://backend-server:8080/*`.\n\nBy default, Nginx uses the default HTTP method (`GET`) when proxying HTTP requests. However, it is possible to specify the HTTP method to use by including the `proxy_method` directive in the configuration.\n\n```\nlocation /api/ {\n    proxy_pass http://backend-server:8080/;\n    proxy_method POST;\n}\n```\n\nThe above configuration tells Nginx to use the `POST` method when forwarding requests to the backend server.\n\n## Configuring Nginx as a Reverse Proxy\n\nIn addition to acting as an HTTP proxy, Nginx can also be used as a reverse proxy. A reverse proxy helps to distribute traffic across multiple servers while still presenting a single point of contact. This configuration can be seen as the reverse of the proxy setup we discussed earlier.\n\nTo configure Nginx as a reverse proxy, we need the `upstream` module and the `proxy_pass` directive. The `upstream` module allows us to define a list of available backends servers that Nginx can send requests to. Here's an example:\n\n```\nupstream backend {\n    server backend-server-1:80;\n    server backend-server-2:80;\n}\n\nserver {\n  listen 80;\n  server_name myserver.com;\n\n  location / {\n      proxy_pass http://backend;\n  }\n}\n```\n\nIn the above configuration, Nginx will forward all requests to `http://myserver.com/*` to the backend servers specified in the `upstream` block. Traffic will be load balanced across the servers in a round-robin manner by default.\n\n## Configuring Nginx as a Load Balancer\n\nAs a reverse proxy, Nginx also performs load balancing of requests to backend servers. This ensures that there is no server overload and that connections are dealt with in an efficient and reliable manner.\n\nNginx offers multiple load balancing algorithms, including round-robin (default), IP hash, and least connections. The round-robin algorithm evenly distributes requests amongst backend servers, whereas the IP hash algorithm hashes the client IP address to ensure that requests from the same IP are always handled by the same server.\n\nHere's an example of how to configure the IP hash algorithm:\n\n```\nupstream backend {\n    ip_hash;\n\n    server backend-server-1:80;\n    server backend-server-2:80;\n}\n\nserver {\n  listen 80;\n  server_name myserver.com;\n\n  location / {\n      proxy_pass http://backend;\n  }\n}\n```\n\nThe `ip_hash;` directive tells Nginx to use the IP hashing algorithm for load balancing. This will ensure that requests from the same IP are always sent to the same server.\n\n## Conclusion\n\nIn this article, we have explored how to use Nginx as a high-performance HTTP proxy. We have covered the basics of HTTP proxying, and delved into the configuration of Nginx as a reverse proxy and load balancer. The features discussed in this article are just the tip of the iceberg; Nginx has many other capabilities and features that make it a great choice for web servers and proxies."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}