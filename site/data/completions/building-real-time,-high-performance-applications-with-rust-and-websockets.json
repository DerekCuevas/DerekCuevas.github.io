{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\", \"Securely Storing Secrets in Rust\", \"How to Write High Performance Elm Code with the Help of Web Workers\", \"The Ultimate Guide to Building and Optimizing GraphQL APIs with Node.js\", \"Building High-Performance Reactive Applications with Rust and Tokio\", \"Mastering GraphQL's Execution Phase with Node.js, TypeScript, and TypeGraphQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader. Ensure that the topic is not related to a previous post. Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Explain information and details in the post step by step."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7KWIwuRhCvlulA7ipFGanQPVK2nJt",
  "object": "chat.completion",
  "created": 1685125094,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 810,
   "completion_tokens": 1242,
   "total_tokens": 2052
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Building Real-Time, High-Performance Applications with Rust and WebSockets\n\nTags: Rust, WebSockets, Real-Time, Performance\n\nWebSockets are a powerful and widely used technology for building web-based real-time applications. Rust is a high-performance language that provides the developer with a powerful set of tools for building high-performance systems. In this post, we will explore how to use Rust and WebSockets to build real-time, high-performance applications.\n\n### Prerequisites\n\n- Basic knowledge of Rust programming language\n- Familiarity with WebSockets protocol\n\n### Setting up the Environment\n\nBefore we start building the application, we need to set up the environment. First, we need to create a new Rust project. We can do this by running the following commands in the terminal:\n\n```shell\n$ cargo new rust-ws-app\n$ cd rust-ws-app\n```\n\nNext, we will add the `tokio` library to our `Cargo.toml` file:\n\n```toml\n[dependencies]\ntokio = { version = \"1.10\", features = [\"full\"] }\n```\n\n### Implementing the Server\n\nTo implement the server, we must first create the event loop and the WebSocket server. We will be using the `tokio` library to create the event loop. We can initialize the event loop by creating a new variable of type `tokio::runtime::Runtime`.\n\n```rust\nuse tokio::runtime::Runtime;\n\nfn main() {\n    let rt = match Runtime::new() {\n        Ok(rt) => rt,\n        Err(e) => {\n            eprintln!(\"Failed to create the event loop: {}\", e);\n            return;\n        }\n    };\n}\n```\n\nWe then need to create the server and bind it to an address. This will allow the WebSocket to receive incoming connections.\n\n```rust\n// Setup the server\nlet server = match WebSocket::new()\n    .bind(\"127.0.0.1:8000\", &rt)\n    .await\n{\n    Ok(server) => server,\n    Err(e) => {\n        eprintln!(\"Failed to bind the server to the address: {}\", e);\n        return;\n    }\n};\n```\n\nOnce we have the server setup, we can start accepting incoming connections:\n\n```rust\n// Start the server\nserver.listen().await;\n```\n\nTo handle incoming messages, we must implement the `WebSocketListener` trait. The `WebSocketListener` trait provides various methods to handle different WebSocket events such as receiving a message and closing the connection.\n\n```rust\nuse tokio::stream::StreamExt;\nuse tokio::sync::mpsc::{UnboundedReceiver, UnboundedSender};\nuse tokio_tungstenite::tungstenite::Message;\n\n#[derive(Debug)]\nenum ServerEvent {\n    NewConnection(\n        tungstenite::protocol::WebSocket<\n            tokio_tungstenite::tungstenite::stream::Stream<\n                tokio::net::TcpStream,\n            >,\n        >,\n    ),\n    Message(Message),\n}\n\nfn process_message(msg: Message) {\n    match msg {\n        Message::Text(txt) => {\n            println!(\"Received a text message: {}\", txt);\n        }\n        Message::Binary(bin) => {\n            println!(\"Received a binary message: {:?}\", bin);\n        }\n        _ => {}\n    }\n}\n\nstruct ChatService {\n    tx: UnboundedSender<Message>,\n}\n\nimpl WebSocketListener for ChatService {\n    fn on_message(&self, msg: Message) {\n        process_message(msg);\n    }\n}\n```\n\nThe `ChatService` struct is our implementation of the `WebSocketListener` trait. We can then register a new service for each incoming connection:\n\n```rust\n// Listen for incoming connections\nwhile let Some(stream) = server.next().await {\n    match stream {\n        Ok(ws_stream) => {\n            let (tx, rx) = tokio::sync::mpsc::unbounded_channel();\n            let peer_addr = ws_stream\n                .peer_addr()\n                .expect(\"WebSocket peer must have an IP address\");\n                \n            let (service, _sender) = ChatService::new(tx);\n            let challenge = Challenge::new_random();\n            let accept_result = challenge.accept(&mut ws_stream);\n            let (peer, ws_stream) = match accept_result {\n                Ok(ws) => {\n                    debug!(\"{}: WebSocket handshake successful\", peer_addr);\n                    let peer = Peer::new(ws_stream, service, rx, peer_addr);\n                    (peer, ws)\n                }\n                Err(e) => {\n                    error!(\n                        \"{}: WebSocket handshake failed: {}\",\n                        peer_addr, e\n                    );\n                    continue;\n                }\n            };\n\n            tokio::spawn(async move {\n                peer.run().await.unwrap_or_default();\n            });\n        }\n        Err(e) => {\n            eprintln!(\"Error accepting the incoming connection: {}\", e);\n            break;\n        }\n    }\n}\n```\n\n### Implementing the Client\n\nTo implement the client, we must first create a WebSocket connection to the server. We can do this by using the `tokio-tungstenite` library.\n\n```rust\nlet (ws_stream, _) = match tokio_tungstenite::connect_async(\"ws://127.0.0.1:8000\").await {\n    Ok((ws_stream, _)) => (ws_stream, tx),\n    Err(e) => {\n        eprintln!(\"Failed to connect to WebSocket server: {}\", e);\n        return;\n    }\n};\n```\n\nOnce we have the WebSocket connection established, we can start sending messages:\n\n```rust\nlet msg = Message::Text(\"Hello, World!\".to_string());\nws_stream.send(msg).await.unwrap();\n```\n\n### Conclusion\n\nIn this post, we explored how to use Rust and WebSockets to build real-time, high-performance applications. We began by setting up the development environment and implemented the server and the client. A real-time application built with Rust and WebSockets can handle a large number of concurrent connections and offer a low-latency solution for real-time applications. Try this for your next project!"
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}