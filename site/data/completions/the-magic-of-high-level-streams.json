{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Using Rust's Pinning API for Safe and Performant Async Programming\", \"Building Scalable REST APIs with Node.js and PostgreSQL\", \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7MrXzH7rY5qnE5jWPZUuGlk8RhEDi",
  "object": "chat.completion",
  "created": 1685683407,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 811,
   "completion_tokens": 1206,
   "total_tokens": 2017
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: The Magic of High-Level Streams\n\nTags: Rust, Streams, Data Streams\n\nAsynchronous programming is hard. When dealing with high-performance systems that need to process large data streams, it can be even harder. But Rust has a sweet solution that makes working with data streams an enjoyable experience: high-level, functional streams.\n\nIn Rust 1.0, Rust introduced `mio` as an asynchronous I/O library, and with Rust 1.39, Rust introduced `async/await`, which makes it even more pleasant to work with asynchronous programming and event-driven programming.\n\nIn this article, we will be exploring Rust's high-level streams by building an example that demonstrates how to work with data streams in Rust.\n\n# Introduction to high-level streams\n\nRust's `Stream` trait provides a definition for a sequence of asynchronous values, most typically used with data streams. A stream processes data in chunks and can be infinite, meaning it is theoretically limited by memory size or available space.\n\nStreams provide a nice abstraction for handling asynchronous data and make it possible to implement backpressure and other flow-control mechanisms.\n\nRust's `futures` library provides a `Stream` trait and also defines useful combinators that can be useful when working with streams. The `Stream` trait represents an asynchronous sequence of values.\n\nAn asynchronous sequence of items can be generated by returning a `Stream` instead of an iterator. This allows us to represent very large or even infinite sequences of data that would not fit in memory.\n\nLet's create a data stream using Rust streams that generates random numbers every 500ms.\n\n```rust\nuse futures::{Stream, pin_mut, stream::{self, Interval}};\nuse rand::prelude::*;\n\nasync fn generate_data_stream() -> impl Stream<Item = i32> {\n    let tick = Interval::new(Duration::from_millis(500));\n    stream::unfold(0, move |_| {\n        let mut rng = thread_rng();\n        let num = rng.gen_range(1, 101);\n        Some((num, async { tick.next().await },))\n    })\n    .map(|(num, _)| num)\n}\n\n#[tokio::main]\nasync fn main() {\n    let data_stream = generate_data_stream();\n    pin_mut!(data_stream);\n\n    while let Some(num) = data_stream.next().await {\n        println!(\"{}\", num);\n    }\n}\n```\n\nThis generates a data stream that generates a random number every 500 milliseconds using `async/await` and Rust streams. We create an `Interval` that will keep on ticking for every 500 milliseconds and store it in `tick`. We will pass `tick` as a state to the `stream::unfold` function along with a closure that generates random numbers using the `rand` crate, creates a tuple with the random number and the next tick, and returns it as an optional value to `stream::unfold`.\n\nIn the main function, we get the stream of data using `generate_data_stream()`, pin it to the stack using `pin_mut`, and loop through the data stream using `while let` and `data_stream.next().await`.\n\nNow let's learn about backpressure and how Rust's streams handle it.\n\n# Backpressure\n\nBackpressure is the ability to manage the rate where a data source produces data and the ability of a data consumer to tell the data source how much data it can receive at any given time. In other words, it's like placing your finger on a garden hose's tip to regulate how much water comes out.\n\nRust supports backpressure through the `futures::stream::Stream` trait and its `futures::stream::StreamExt` trait. `StreamExt` defines combinators that allow us to create a backpressure mechanism to handle data streams with the following two combinators:\n\n- The `futures::stream::StreamExt::buffer()` combinator allows us to define an upper bound on the number of items a stream can buffer before pausing the source. If the buffer size exceeds the defined capacity, backpressure will be applied.\n\n- The `futures::stream::StreamExt::throttle()` combinator allows us to define a minimum interval time between items.\n\nLet's see how these combinators work with a code snippet that generates random numbers every 500 milliseconds and prints them out with a buffer size of 3.\n\n```rust\nuse futures::{Stream, stream::{self, Interval}, StreamExt};\nuse rand::prelude::*;\nuse std::time::{Duration, Instant};\n\nasync fn generate_data_stream() -> impl Stream<Item = i32> {\n    let tick = Interval::new(Duration::from_millis(500));\n    stream::unfold(0, move |_| {\n        let mut rng = thread_rng();\n        let num = rng.gen_range(1, 101);\n        Some((num, async { tick.next().await },))\n    })\n    .map(|(num, _)| num)\n}\n\n#[tokio::main]\nasync fn main() {\n    let data_stream = generate_data_stream().buffer_unordered(3);\n    let mut interval = Interval::new_at(Instant::now(), Duration::from_secs(1));\n    while let Some(_) = interval.next().await {\n        if let Some(num) = data_stream.next().await {\n            println!(\"{}\", num);\n        }\n    }\n}\n```\n\nThis generates a data stream that generates a random number every 500 milliseconds and prints it out with a buffer size of 3. We used the `buffer_unordered` function with a size of 3 to apply backpressure when the buffer size is greater than 3.\n\nFunctions that return a stream are useful for working with data streams that are too large to fit into memory and when the result cannot be determined immediately.\n\nRust's high-level streams provide a powerful abstraction for handling asynchronous data. By providing combinators that can help to apply useful backpressure mechanisms, we can write more efficient and performant applications."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}