{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\", \"Building Robust Elixir Back-End APIs with Phoenix Contexts\", \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\", \"Mastering Browser Storage in TypeScript\", \"Mastering Rust's `std::env::args_os()`\", \"Building Composable, Scalable, and Reusable Redux Reducers\", \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\", \"The Magic of High-Level Streams\", \"Using Rust's Pinning API for Safe and Performant Async Programming\", \"Building Scalable REST APIs with Node.js and PostgreSQL\", \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7OETh4ebmQZmgo8LJYy0bnUg8RNor",
  "object": "chat.completion",
  "created": 1686009881,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 820,
   "completion_tokens": 959,
   "total_tokens": 1779
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Building a High-Availability Microservice Architecture with Modern C++\n\nTags: C++, Microservices, High-Availability\n\nIntroduction:\nDistributed systems have become the norm in modern web development. A microservice architecture is one way to build such a system, allowing us to isolate components and scale more easily. Building a microservice is often done with higher-level languages, but C++ has become a popular choice for high-performance at scale. In this post, we will take a deeper look into designing and deploying a high-availability, distributed C++ microservice architecture.\n\nSection 1: Choosing a communication protocol\nA microservice architecture requires communication between many separate services. In order to achieve a high-availability system, a message-oriented middleware solution can be implemented to buffer messages and allow the services to communicate asynchronously. Apache Kafka is often used as a solution, but ZeroMQ is a popular lightweight alternative that can handle large numbers of messages and provides multiple patterns of communication. Let's see how a ZeroMQ PUB-SUB communication model can be used to build a robust microservice system. \n\n```\n// ZeroMQ PUB building\n\nzmq::context_t context{1};\nzmq::socket_t publisher{context, zmq::socket_type::pub};\npublisher.bind(\"tcp://*:5556\");\n\n// Publish a message\nwhile (true) {\n    const std::string json_message = create_message();\n    zmq::message_t zmq_message{json_message.length()};\n    memcpy(zmq_message.data(), json_message.c_str(), json_message.length());\n    publisher.send(zmq_message); \n}\n```\n\n```\n// ZeroMQ SUB building\n\nzmq::context_t context{1};\nzmq::socket_t subscriber{context, zmq::socket_type::sub};\nsubscriber.connect(\"tcp://localhost:5556\");\nsubscriber.setsockopt(ZMQ_SUBSCRIBE, \"\", 0);\n\n// Wait for a message\nwhile (true) {\n    zmq::message_t zmq_message{};\n    subscriber.recv(&zmq_message);\n    const std::string json_message = std::string(static_cast<char*>(zmq_message.data()), zmq_message.size());\n    process_message(json_message);\n}\n```\n\nSection 2: Integrating a load balancer\nOnce the communication protocol is selected, we can focus on scalability and availability. A common pattern used in a microservice architecture is the use of a load balancer, distributing load evenly across multiple services to avoid overwhelming any one particular instance. Nginx is a popular open source web server and reverse proxy that can be used as a load balancer. Let's see how Nginx can be configured to balance external requests to multiple C++ microservices.\n\n```\nhttp {\n  upstream backend {\n    least_conn;\n\n    server backend1.example.com;\n    server backend2.example.com;\n    server backend3.example.com;\n  }\n\n  server {\n    listen 80;\n    server_name example.com;\n\n    location / {\n      proxy_pass http://backend;\n    }\n  }\n}\n```\n\nSection 3: Implementing a backup and recovery system\nIn order to maintain high availability, it's important to also consider failover and recovery. C++ microservices can be designed with automatic service recovery and backup redundancy plans. In order to design a system like this, individual microservices must be identified with their own service-level agreements and failure modes. Amazon Simple Storage Service (S3) or Google Cloud Storage are popular choices for off-site backup storage. Let's see how a backup system can be implemented using S3.\n\n```\n// S3 backup\nAws::S3::S3Client client;\n\nAws::S3::Model::PutObjectRequest put_object_request;\nput_object_request.WithBucket(\"my-bucket\")\n                   .WithKey(\"my-key\")\n                   .WithBody(data_stream);\n\nconst Aws::S3::Model::PutObjectOutcome put_object_outcome = client.PutObject(put_object_request);\n\nif (put_object_outcome.IsSuccess()) {\n    std::cout << \"Object successfully uploaded to S3\" << std::endl;\n} else {\n    std::cout << \"Error uploading object to S3: \" << put_object_outcome.GetError().GetMessage() << std::endl;\n}\n```\n\nSection 4: Conclusion\nBuilding a high-availability C++ microservice architecture requires careful consideration of communication protocol, load balancing, and redundancy. By utilizing technologies like ZeroMQ, Nginx, and AWS S3, we can construct a highly-available microservice system that can scale to meet the demands of a modern distributed application.\n\nCombining reliability and performance, C++ is a great option for building a high-performing microservice architecture. The implementation of microservices must be done carefully and often take a lot of planning."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}