{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LxxD91Gcqzr9lv0wBVc8EYrIa6J7",
  "object": "chat.completion",
  "created": 1685469707,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 813,
   "completion_tokens": 1669,
   "total_tokens": 2482
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\n\nTags: Rust, Pulsar, Distributed Systems\n\nAsynchronous and non-blocking programming patterns are in high demand in today's distributed systems. One of the most common approaches for building highly scalable, real-time message-based applications is by using message brokers. In this post, we will explore how to build a high-performance, real-time message-based application with Rust and the Pulsar message broker.\n\n## What is Pulsar?\nPulsar is a next-generation, distributed messaging and streaming platform designed to solve many of the limitations of existing message brokers. It provides advanced features such as publish-subscribe messaging, real-time event streaming, and message durability. It is also a cloud-native, multi-tenant solution that can scale to millions of messages per second.\n\n## Using Rust with Pulsar\nRust has become increasingly popular for building high-performance, concurrent systems. Rust's unique ownership model, memory safety, and zero-cost abstractions make it a great choice for building real-time, non-blocking systems. With the Rust Pulsar client library, we can create fast and reliable message-based applications with ease.\n\nLet's take a look at how to use Rust with Pulsar to build a simple real-time chat server.\n\n## Setting up the Environment\nBefore getting started, make sure that you have Rust and Pulsar installed on your development machine.\n\n```rust\n// Import the pulsar-rs library\nuse pulsar::producer::Producer;\nuse pulsar::{Error, Pulsar};\nuse std::io::{self, BufRead};\nuse std::thread;\n\nfn main() -> Result<(), Error> {\n    // Initialize a new Pulsar client\n    let client = Pulsar::builder(\"pulsar://localhost:6650\").build()?;\n\n    // Initialize a new producer\n    let mut producer = client\n        .producer()\n        .with_topic(\"persistent://public/default/chat\")\n        .with_name(\"rust-producer-1\")\n        .build()?;\n\n    // Read user input and publish messages to the chat topic\n    loop {\n        let mut message = String::new();\n        let stdin = io::stdin();\n        let mut handle = stdin.lock();\n        handle.read_line(&mut message)?;\n        producer.send(message.as_bytes(), None)?;\n    }\n}\n```\nThe above code demonstrates how to initialize a Pulsar client, create a producer, and publish messages to a Pulsar topic.\n\n## Consuming Messages with Rust\nWith the Rust Pulsar client, consuming messages is straightforward. We can consume messages either individually or in batches.\n\n```rust\n// Consume messages from a Pulsar topic\nlet mut consumer = client\n    .consumer()\n    .with_topic(\"persistent://public/default/chat\")\n    .with_consumer_name(\"rust-consumer-1\")\n    .with_subscription_type(pulsar::ConsumerType::Exclusive)\n    .build()?;\n\n// Consume messages individually\nlet message = consumer.receive().await?;\nprintln!(\n    \"Received message: {}\",\n    String::from_utf8_lossy(message.payload())\n);\n\n// Consume messages in batches\nlet messages = consumer.batch_receive().await?;\nfor message in messages {\n    println!(\n        \"Received message: {}\",\n        String::from_utf8_lossy(message.payload())\n    );\n}\n```\nIn the above example, we create a new consumer and consume messages from a Pulsar topic individually and in batches.\n\n## Building Chat Applications with Rust and Pulsar\nNow that we have seen how to produce and consume messages with Rust and Pulsar, let's build a real-time chat application leveraging Pulsar topics.\n\nTo accomplish this, we will use a WebSocket server to receive client requests and broadcast messages to connected clients through the Pulsar message broker.\n\n```rust\n// Import the necessary libraries\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse futures::stream::StreamExt;\nuse tokio::sync::mpsc::{channel, Receiver, Sender};\nuse tokio::sync::Mutex;\nuse tokio_tungstenite::tungstenite::Message;\nuse tokio_tungstenite::{accept_async, WebSocketStream};\nuse tokio::task;\n\nuse pulsar::{Consumer, Pulsar, TokioExecutor};\n\n// Set up global variables for connected clients, channels to receive and broadcast messages, and a lock for thread-safe data transfer\ntype PeerMap = Arc<Mutex<HashMap<String, Sender<Message>>>>;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Set up a new pulsar instance\n    let client = Pulsar::builder(\"pulsar://localhost:6650\")\n        .executor(TokioExecutor)\n        .build()\n        .await?;\n\n    // Set up the chat topic\n    let topic = \"persistent://public/default/chat\";\n\n    // Clone the peer map to make it accessible in both the broadcasting and receiving loops\n    let peers = PeerMap::new(Mutex::new(HashMap::new()));\n    let peers_cloned = peers.clone();\n\n    // Start a new task that broadcasts messages received from the Pulsar topic to all connected clients.\n    task::spawn(async move {\n        let mut consumer: Consumer;\n        loop {\n            consumer = client\n                .consumer()\n                .with_topic(topic)\n                .with_consumer_name(\"rust-consumer-1\")\n                .with_subscription_type(pulsar::ConsumerType::Exclusive)\n                .build()\n                .await.unwrap();\n\n            if let Ok(Some(msg)) = consumer.try_recv().await {\n                let msg_string = String::from_utf8_lossy(&msg.payload().to_vec());\n                // Broadcast the received message to all connected clients\n                let mut guard = peers.lock().await;\n                for (_id, tx) in guard.iter_mut() {\n                    let _ = tx.send(Message::text(msg_string.to_owned())).await;\n                }\n            }\n        }\n    });\n\n    // Start a WebSocket server and spawn client connections as individual futures\n    let mut listener = tokio::net::TcpListener::bind(\"127.0.0.1:9001\").await?;\n    while let Ok((stream, _)) = listener.accept().await {\n        let peer_map = peers_cloned.clone();\n        task::spawn(async move {\n            let ws_stream = accept_async(stream).await.unwrap();\n            let (mut tx, rx) = channel(100);\n\n            // Add the new connection's sender to the list of connected clients\n            let mut guard = peer_map.lock().await;\n            let new_peer_id = uuid::Uuid::new_v4().to_string();\n            guard.insert(new_peer_id.clone(), tx);\n\n            // Receive messages from this client and broadcast them to all connected clients\n            let receive_msgs = rx.map(Ok).forward(ws_stream.clone());\n            let broadcast_msgs = {\n                async move {\n                    while let Some(msg) = ws_stream.message().await.unwrap().into_text() {\n                        let mut guard = peer_map.lock().await;\n                        for (id, tx) in guard.iter_mut() {\n                            tx.send(Message::text(format!(\n                                \"[{}] {}\",\n                                id,\n                                msg\n                            ))).await;\n                        }\n                    }\n                }\n            };\n\n            tokio::select! {\n                _ = receive_msgs => (),\n                _ = broadcast_msgs => (),\n            }\n\n            // Remove the sender from the list of connected clients\n            guard.remove(&new_peer_id);\n        });\n    }\n\n    Ok(())\n}\n```\nThe above code demonstrates how to set up a real-time chat server with Rust and Pulsar using a WebSocket server and broadcasting messages through Pulsar.\n \n## Conclusion\nIn this post, we have explored how to use Rust and Pulsar to build high-performance message-based applications. We saw how to produce and consume messages using the Rust Pulsar client, and leveraged that knowledge to build a real-time chat application with Pulsar topics. With Rust and Pulsar, you can create fast, scalable, and reliable message-based applications with ease."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}