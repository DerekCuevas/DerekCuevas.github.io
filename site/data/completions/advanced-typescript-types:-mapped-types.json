{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\", \"Building Real-Time, High-Performance Applications with Rust and WebSockets\", \"How to Build a Distributed System with Rust and Apache Pulsar\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LbTSjh8AM2msA8NUBh3QaKBVXvJc",
  "object": "chat.completion",
  "created": 1685383294,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 837,
   "completion_tokens": 1171,
   "total_tokens": 2008
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Advanced TypeScript Types: Mapped Types\n\nTags: TypeScript, Advanced TypeScript Types, Mapped Types\n\nTypeScript is a powerful typed superset of JavaScript. TypeScript introduces types to give static type-checking capabilities to JavaScript. Types can help catch a range of errors before they hit production, even before the code executes. TypeScript also gives greater functionality to the language with extensions that add features like mixins, abstract classes, and private properties.\n\nTypeScript also lets developers define and create Mapped Types, which give the ability to create types that transform a type’s properties and create a new type. Mapped Types provides a set of new types that are used to modify existing types in TypeScript. Mapped Types are a useful technique for transforming a type into a more specific type, adding readonly properties or for creating type safe copies of existing types. In this article, we’ll explore Mapped Types and the different types of transformations and their use cases.\n\n## Basic Mapped Types\n\nMapped Types allow us to transform a specific properties from an existing type to create a new type. \n\n```typescript\ntype Person = {\n  firstname: string;\n  lastname: string;\n  age: number;\n};\n\ntype ReadonlyPerson = {\n  readonly [key in keyof Person]: Person[key];\n};\n\ntype PartialPerson = {\n  [key in keyof Person]?: Person[key];\n};\n```\n\nIn the example above, we’ve defined a type `Person` which contains properties like firstname, lastname, and age. We can create new types by transforming `Person`. In this case, we create two new types `ReadonlyPerson` and `PartialPerson`. \n\nThe `ReadonlyPerson` type is created by using the `in` operator to iterate over the properties of `Person` and create a new type with read-only access to the properties of `Person`.\n\n```typescript\ntype ReadonlyPerson = {\n  readonly [key in keyof Person]: Person[key];\n};\n```\n\nThe `PartialPerson` type on the other hand is created by using the `?` operator to make all properties of `Person` optional.\n\n```typescript\ntype PartialPerson = {\n  [key in keyof Person]?: Person[key];\n};\n```\n\nIn both cases, we use the `keyof` operator to get all keys (properties) of `Person`. The `Person[key]` part references the value of each key and associates it with the newly created types.\n\n## Transforming Property Types\n\nMapped Types not only allow us to transform an existing type but also let us manipulate the type of the properties. For example, we can change the type of a property from a `string` to a `number`.\n\n```typescript\ntype Person = {\n  firstname: string;\n  lastname: string;\n  age: number;\n};\n\ntype PersonNumber = {\n  [key in keyof Person]: number;\n};\n\ntype PersonToString = {\n  [key in keyof Person]: string;\n};\n```\n\nIn the example above, we create two types `PersonNumber` and `PersonToString` where all properties `Person` are transformed respectively to the `number` and `string` types. \n\n## Conditional Types\n\nIn addition to simple mappings, Mapped Types can also use conditions to transform types. This can be useful when needing to add constraints and perform operations on types in a more generic way. \n\n```typescript\ntype Person = {\n  firstname: string;\n  lastname: string;\n  age: number;\n  isMarried: boolean;\n};\n\ntype OptionalAndNullablePerson<T> = {\n  [key in keyof T]?: T[key] | null;\n};\n\ntype NullablePerson = OptionalAndNullablePerson<Person>;\n\ntype NullableAndMaybeMarriedPerson<T> = {\n  [key in keyof T]?: T[key] | null;\n} & { isMarried?: true };\n\ntype NullableAndMaybeMarried = NullableAndMaybeMarriedPerson<Person>;\n```\n\nIn the example above, we create two types: `NullablePerson` and `NullableAndMaybeMarriedPerson`.\n\n`NullablePerson` type transforms all properties of the `Person` type into types that can either be optional or nullable. \n\n```typescript\ntype OptionalAndNullablePerson<T> = {\n  [key in keyof T]?: T[key] | null;\n};\n\ntype NullablePerson = OptionalAndNullablePerson<Person>;\n```\n\nIn the case of `NullableAndMaybeMarriedPerson`, we add an extra condition that ensures the `isMarried` property to be nullable or optional while the rest are the same as `NullablePerson`.\n\n```typescript\ntype NullableAndMaybeMarriedPerson<T> = {\n  [key in keyof T]?: T[key] | null;\n} & { isMarried?: true };\n\ntype NullableAndMaybeMarried = NullableAndMaybeMarriedPerson<Person>;\n```\n\nMapped Types provides a powerful feature in Typescript that allows us to create new types from existing ones. Mapped types give the ability to create transformations on property types or modify existing types to create new types. \n\nIn summary, Mapped Types can:\n\n- Create read-only versions of existing types.\n- Create partial types with optional properties or nullable values.\n- Create new types with the same properties but different types.\n- Replace the value of certain properties with another type.\n- Employ conditions to create new types. \n\nMapped Types can help increase the simplicity and clarity of your code by creating one-off types rather than repeating type definitions throughout your application.\n\n## Conclusion\n\nWhilst simple in concept, Mapped Types can unlock a whole range of potential in TypeScript. It allows anyone using TypeScript to explore and transform the complexities of existing types to create new types that are better suited to their needs. Whether it’s adding optional or nullable fields or creating entirely new types with different property types, Mapped Types have a range of useful applications."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}