{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas' Résumé\"\ndate = \"2023-06-11\"\nor = \"Derek Cuevas\"\n+++\n\n# Derek Cuevas\n\nSenior Software Engineer | [GitHub](https://github.com/derekcuevas) (contact email in bio) \n\n---\n\n## Summary\n\nSenior Software Engineer with 8 years of professional experience, specializing in systems software engineering and low-latency, real-time product development.\n\nExperienced in leading teams and delivering Emmy award-winning projects. Passionate about functional programming and building high performance real-time systems. Skilled in a variety of programming languages and technologies with expertise in [Rust](https://www.rust-lang.org/) and [TypeScript](https://www.typescriptlang.org/).\n\n---\n\n## Programming Languages\n\n- **Proficient:** Rust, TypeScript (& JavaScript), Elm, Clojure\n- **Experienced:** Elixir, Swift, Objective-C, SQL\n\n---\n\n## Technologies, Skills, and Interests\n\n- **Rust:** Tokio, Futures, Hyper, Actix, Warp\n- **Platforms and Services:** AWS, Docker,  PostgreSQL, Redis, Apache Pulsar, RabbitMQ, Prometheus, GitLab CI/CD, Node.js, Deno, HTML & CSS\n- **Tooling:** Git, Vim, Bash\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI, Phoenix\n- **Protocols:** HTTP, GraphQL, WebSockets, ØMQ, Pub/Sub, JSON, MessagePack, Protobuf, FlatBuffers\n- **Paradigms:** Functional Programming, Real-time Systems\n\n---\n\n## Professional Experience\n\n### Senior Software Engineer II (Lead), Second Spectrum (acquired by Genius Sports)\n(*January 2021 - Current*)\n\n[https://geniussports.com/](https://geniussports.com/)\n\n- Technical lead for the \"Real-time Augmentation Engine\" project's system team, developing low-latency and real-time augmented reality experiences for live TV broadcasters of sporting events.\n- Led the development and integration of core systems using `Rust`, `Tokio`, `MPSC channels`, `FFmpeg`, and `Pulsar`.\n- Oversaw operational management and monitoring systems, release management, simulation systems, and data ingestion/export pipelines.\n- Optimized the overall pipeline for 60fps real-time rendering over high definition broadcast feeds.\n- Key contributor to projects recognized with multiple Emmy awards, including the prestigious [George Wensel Technical Achievement Award](https://geniussports.com/customer-stories/cbs-and-genius-win-sports-emmy-for-romovision/) and Amazon's [Outstanding Interactive Experience](https://www.aboutamazon.com/news/entertainment/thursday-night-football-on-prime-video-wins-sports-emmy-award) at the `Sports Emmys`.\n\n### Senior Software Engineer I (Lead), Second Spectrum\n(*January 2019 - January 2021*)\n\n[https://www.secondspectrum.com/](https://www.secondspectrum.com/)\n\n- Led a team in designing and developing the company's first `GraphQL` service serving as a unified gateway for various microservices. Built upon the `Apollo` server framework leveraging `Node.js`, `TypeScript`, `PostgreSQL`, and `Redis` for caching and pub/sub.\n- Developed a dashboard built with `Three.js` for visualizing 3D player tracking datasets and highlighting data discrepancies.\n- Created a prototype `iOS` application for video highlights using `Swift`, `SwiftUI`, and the `Combine` framework.\n- Mentored interns and fellow engineers, fostering collaboration and knowledge sharing.\n\n### Software Engineer, Second Spectrum\n(*August 2016 - January 2019*)\n\n[https://www.secondspectrum.com/](https://www.secondspectrum.com/)\n\n- Developed the operational and quality assurance management application for the company's optical player tracking system. Stack included `Elixir` (with the `Phoenix` framework), `React`, and heavy use of `WebSockets` to sync and display corrections to operators in near real-time.\n- Improved operator efficiency by 100% through the implementation of an automated task selection system.\n- Led the development of the LA Clipper's live streaming web and mobile application \"Clippers CourtVision\". Stack included `Elm` for the web front-end and `React Native` for the mobile app.\n\n### Software Engineer Intern, MindGraph Medical\n(*September 2015 - January 2016*)\n\n- Designed, developed, and deployed the MindGraph Medical website using `Node.js`, `jQuery`, and `Bootstrap`.\n\n---\n\n## Education\n\n**B.S. Computer Science, San Diego State University, San Diego**\n\n(*Class of 2016*)\n\n- [Advanced Certificate in Web and Mobile Applications Development](https://cs.sdsu.edu/about/)\n\n---\n\n## Personal Projects\n\n- [FYGT](https://github.com/DerekCuevas/derekcuevas.github.io): An experimental blog built with `Hugo`, `Deno`, and `ChatGPT`.\n- [Advent of Code 2022](https://github.com/DerekCuevas/advent-of-code-2022): Solutions to Advent of Code programming problems using functional approaches in `Clojure`.\n- [Interview Cake Algorithms Problem Set](https://github.com/DerekCuevas/interview-cake-clj): Solutions to the interview cake programming problems also by exploring functional approaches in `Clojure`.\n- [Friend List](https://github.com/DerekCuevas/friend-list): A non-trivial programming challenge exploring asynchronous side effects with different programming patterns.\n- [Redux Meta Reducer](https://github.com/DerekCuevas/redux-meta-reducer): A `Redux` higher-order reducer for simplifying the state of fetched data.\n- [Avowal](https://github.com/DerekCuevas/avowal): An asynchronous form validation library for `JavaScript`.\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 40 posts include: \"Securely Managing Secrets in Production Applications\", \"Implementing the Factory Method Design Pattern in Dart\", \"Boosting Rust Performance with Allocator Selection\", \"Building Real-Time Audio Applications with WebRTC and Rust\", \"Rust's Pinning API: A Comprehensive Guide\", \"Building a Highly Scalable and Fault-Tolerant Load Balancer with Rust\", \"How to Use AWS Fargate for Highly Scalable and Serverless Containers\", \"How to Build a Recommendation Engine with Apache Spark\", \"Building a Distributed Key-Value Store on Top of Apache Kafka\", \"Building a GraphQL API with Actix-Web and Diesel\", \"Building a High-Performance HTTP Proxy with Nginx\", \"How to Use Kafka to Build Scalable and Fault-Tolerant Distributed Systems\", \"Advanced Techniques for Using PostgreSQL JSONB Data Type\", \"Writing Secure Rust Code: A Deep Dive into Memory Safety\", \"Fine-tuning BERT for Question Answering - A Step-by-Step Guide\", \"How to Use the Decorator Pattern for Flexible and Extensible Code\", \"A Deep Dive into Multithreading with Clojure\", \"How to Design Reactive Microservices Using Event-Driven Architecture\", \"Writing Efficient SQL Queries: Tips and Tricks\", \"Mastering Connection Pooling in Django\", \"Mastering the Actor Model Concurrency Paradigm in Elixir\", \"How to use Elm to build maintainable, efficient, and bug-free front-end applications\", \"How to Use Generators to Create Infinite Sequences in Python\", \"Building High Performance Distributed Data Pipelines with Apache Flink\", \"Implementing a Consistent Hashing Algorithm in TypeScript\", \"The Event Sourcing Design Pattern in TypeScript\", \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\", \"Building Robust Elixir Back-End APIs with Phoenix Contexts\", \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Rust's Standard Library Function `mem::forget()`\", \"Build a Scalable, Maintainable, and Performant Full-Text Search System for Your Application with Elasticsearch\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\", \"Mastering Browser Storage in TypeScript\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include or link to images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7Qg9MSKgeMbVpFJQTivTkBMmtTZJ3",
  "object": "chat.completion",
  "created": 1686592908,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 2060,
   "completion_tokens": 1118,
   "total_tokens": 3178
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Writing a Domain-Specific Language (DSL) in Haskell\n\nTags: Haskell, Domain-Specific Language, DSL\n\n## Introduction\n\nDomain-Specific Languages (DSLs) are a powerful tool that can greatly simplify programming in a specific field. They are designed to resemble the jargon and notation of a particular domain, which makes them more concise and easier to understand than general-purpose programming languages.\n\nHaskell is a great language to build DSLs because of its ability for abstraction and expressiveness. In this post, we will explore why DSLs are important and how to build a DSL in Haskell.\n\n## Why Build a Domain-Specific Language?\n\nBuilding a custom DSL can prove to be very useful in many situations. A custom DSL can help in the following scenarios:\n\n- Reduce complexity\n- Increase productivity\n- Improve usability\n\nWhen a problem requires a lot of boilerplate code or when there are a lot of complicated steps involved in its solution, building a DSL can provide a more concise way to solve the problem. For example, a configuration file may require a lot of repetitive configuration code to set up various components. A DSL can help to reduce this complexity and provide a more efficient way to configure the components.\n\nDSLs can also be used to increase productivity by providing a more streamlined way of performing specific tasks. DSLs can help in building compilers, query languages, graphics tools, etc.\n\nDSLs with intuitive notation can also improve usability, providing a more natural way to read and write code in a particular domain. \n\n## Building a DSL in Haskell\n\nIn order to build a DSL in Haskell, we can use the `Parsec` library, which provides powerful parsing tools for working with textual input.\n\nIn this example, we will be building a simple file format parser that extracts a list of items and their quantities from a text file. The format of the file is as follows:\n\n```\nitem1: quantity1\nitem2: quantity2\nitem3: quantity3\n```\n\nWe want to extract a list of items and their corresponding quantities from this file in a Haskell program.\n\n### Defining the Data Type\n\nFirstly, we need to define the data type that will hold the information captured from the input file. In this case, we will define a simple data type called `Quantity`:\n\n```haskell\ndata Quantity = Quantity Int deriving (Show)\n```\n\nNow we define another data type `Item` which has a name and a quantity:\n\n```haskell\ndata Item = Item { name :: String, quantity :: Quantity } deriving (Show)\n```\n\nSo our example output should look like this: \n\n```haskell\n[Item {name = \"item1\", quantity = Quantity 10}, Item {name = \"item2\", quantity = Quantity 20}, Item {name = \"item3\", quantity = Quantity 30}]\n```\n\n### Parsing the Input\n\nNow we need to parse the input file into our data structure. We need to define the grammar of the file format and write a parser for it using the `Parsec` library.\n\nThe grammar of our file format is:\n\n```\nfile       ::= line*\nline       ::= name ':' white space quantity newline\nname       ::= text\nquantity   ::= number\ntext       ::= char+\nnumber     ::= digit+\nwhite space::= ' '+\nnewline    ::= '\\r'? '\\n'\nchar       ::= any character except ':' and newline\n```\n\nNow we need to write a parser for our grammar using `Parsec`. We will define a parser for each nonterminal in our grammar:\n\n```haskell\n-- Parses the whole file\nparseFile :: Parser [Item]\nparseFile = many parseLine\n\n-- Parses each line of the file\nparseLine :: Parser Item\nparseLine = do\n  name <- parseName\n  _ <- char ':'\n  skipWhiteSpace\n  qty <- parseQuantity\n  skipOptionalEndOfLine\n  return $ Item { name = name, quantity = qty }\n\n-- Parses the name of an item\nparseName :: Parser String\nparseName = many $ noneOf \":\\n\"\n\n-- Parses the quantity of an item\nparseQuantity :: Parser Quantity\nparseQuantity = Quantity . read <$> many digit\n\n-- Skips the white space\nskipWhiteSpace :: Parser ()\nskipWhiteSpace = void $ many $ oneOf \" \\t\"\n\n-- Skips the optional end-of-line token\nskipOptionalEndOfLine :: Parser ()\nskipOptionalEndOfLine = optional endOfLine >> skipWhiteSpace\n```\n\nNow we can test our parser with an input file:\n\n```\nitem1: 10\nitem2: 20\nitem3: 30\n```\n\n```haskell\nlet items = parse parseFile \"\" \"item1: 10\\nitem2: 20\\nitem3: 30\\n\"\nprint items\n```\n\nThe output will be:\n\n```\nRight [Item {name = \"item1\", quantity = Quantity 10}, Item {name = \"item2\", quantity = Quantity 20}, Item {name = \"item3\", quantity = Quantity 30}]\n```\n\n## Conclusion\n\nBuilding Domain-Specific Languages (DSLs) can greatly simplify programming in a specific field, improving productivity, reducing complexity and improving usability. Haskell provides excellent support for building DSLs, and the `Parsec` library provides powerful parsing tools for working with textual input. In this post, we explored how to build a DSL in Haskell using `Parsec` by creating a simple file format parser."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}