{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Design Reactive Microservices Using Event-Driven Architecture\", \"Writing Efficient SQL Queries: Tips and Tricks\", \"Mastering Connection Pooling in Django\", \"Mastering the Actor Model Concurrency Paradigm in Elixir\", \"How to use Elm to build maintainable, efficient, and bug-free front-end applications\", \"How to Use Generators to Create Infinite Sequences in Python\", \"Building High Performance Distributed Data Pipelines with Apache Flink\", \"Implementing a Consistent Hashing Algorithm in TypeScript\", \"The Event Sourcing Design Pattern in TypeScript\", \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\", \"Building Robust Elixir Back-End APIs with Phoenix Contexts\", \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7PEF6J4hLl7sNIpVYinC8GMpuWIS2",
  "object": "chat.completion",
  "created": 1686247304,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 823,
   "completion_tokens": 861,
   "total_tokens": 1684
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: A Deep Dive into Multithreading with Clojure\n\nTags: Clojure, Multithreading, Concurrency\n\n## Introduction\n\nIn today's world, with an ever-growing amount of data to process, making effective use of available resources becomes a necessity. While single-threaded applications seem to be a thing of the past, the shift towards multi-threading is gaining momentum. Clojure is known to provide excellent support for concurrency. In this post, we'll explore the principles of multithreading with Clojure.\n\n## Understanding Concurrency\n\nFirst, let's gain a basic understanding of concurrency:\n\n>Concurrency is a property of systems in which several independent tasks are executing simultaneously.\n\nHowever, there's a difference between concurrency and parallelism:\n\n>Parallelism is the simultaneous execution of multiple tasks on multiple processors.\n\nSo, although two tasks may appear to execute at the same time, with multithreading, they're actually executing on separate processors.\n\n## Creating Threads with 'future'\n\nClojure provides the 'future' macro for creating new threads. Here's an example that demonstrates creating a thread using the future macro to calculate the square of a number:\n\n```clojure\n(defn square [x]\n  (* x x))\n\n(def result (future (square 5)))\n```\n\nIn the above example, we define a function 'square' that accepts a number as an argument and returns the square of the number. Next, we create a new thread that will run the 'square' function and we pass the number 5 as an argument. We assign the result of the future function to a variable named 'result'. Once the future is completed, we can retrieve its value by dereferencing the future as shown below:\n\n```clojure\n@(future-value result)\n```\n\nThe '@' symbol is a shorthand notation of 'deref'. \n\n## Using 'promise' for communication\n\nOne way to communicate between threads is to use a promise which provides a way for a thread to communicate a value to another thread. Let's illustrate this by updating the previous example:\n\n```clojure\n(defn square [x]\n  (* x x))\n\n(def p (promise))\n\n(future\n  (deliver p (square 5)))\n\n(deref p)\n```\n\nIn the above example, we first create a promise using the 'promise' function. Next, we create a thread and call the square function with the argument 5. Once the result of the square function is available, we use the deliver function on the promise to send the value to the main thread. Finally, we use the deref function on the promise to get the value received, which should be 25.\n\n## Synchronized Access\n\nWhile we're on the topic of communication between threads, it's important to look at how synchronization works in Clojure. Synchronization is used to ensure that different threads access a shared resource one at a time, hence avoiding any race conditions and ensuring consistency. Here's an example that demonstrates synchronized access to a shared resource:\n\n```clojure\n(def counter (atom 0))\n\n(defn increment []\n  (swap! counter inc))\n\n(dotimes [n 10]\n  (future (dotimes [m 10000]\n            (increment))))\n\n\nThread/sleep 3000\n\n(prn @counter)\n```\n\nIn the above example, we define the 'counter' variable which is an atom with an initial value of 0. Next, we define the 'increment' function which uses the 'swap!' function to increment the counter. We create ten threads, and each thread runs a loop that calls the 'increment' function 10,000 times. After all the threads have finished executing, we wait for 3 seconds and print the counter value. Since the threads are synchronized, the counter should be 100,000.\n\n## Conclusion\n\nIn this post, we explored the fundamental principles of multithreading with Clojure. We covered how to create threads using the 'future' macro, how to communicate between threads using 'promise', and how to use synchronization to ensure consistency while accessing shared resources. Multithreading is a powerful tool in the arsenal of a software developer, and it's important to understand how to use this tool effectively in order to create safe and efficient software."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}