{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\", \"Securely Storing Secrets in Rust\", \"How to Write High Performance Elm Code with the Help of Web Workers\", \"The Ultimate Guide to Building and Optimizing GraphQL APIs with Node.js\", \"Building High-Performance Reactive Applications with Rust and Tokio\", \"Mastering GraphQL's Execution Phase with Node.js, TypeScript, and TypeGraphQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader. Ensure that the topic is not related to a previous post. Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Explain information and details in the post step by step."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7KQQxN7xT3U2JpaZkPPiR45WKdWBD",
  "object": "chat.completion",
  "created": 1685102527,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 810,
   "completion_tokens": 794,
   "total_tokens": 1604
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: How to Build a Distributed System with Rust and Apache Pulsar\n\nTags: Rust, Distributed Systems, Apache Pulsar\n\nDistributed systems are becoming increasingly popular for building highly available and fault-tolerant applications. Rust, with its excellent performance and memory safety, is a great language choice for building such systems. In this tutorial, we will build a distributed system with Rust and Apache Pulsar.\n\n## What is Apache Pulsar?\nApache Pulsar is a distributed messaging and streaming platform that provides a unified messaging model and a variety of APIs, such as pub-sub and queue semantics. It offers many features out of the box, including geo-replication, multi-tenancy, and guaranteed message delivery.\n\n## Prerequisites\n- Rust 1.40.0 or later\n- Apache Pulsar 2.8.0 or later\n\n## Setting Up\nFirst, we will create a new Rust project and add the required dependencies:\n\n```rust\n[dependencies]\npulsar-client = \"0.42.0\"\n```\n\nNext, we need to start up Pulsar. We can do this easily using Docker:\n```bash\ndocker run -it \\\n  -p 6650:6650 \\\n  -p 8080:8080 \\\n  apachepulsar/pulsar:latest \\\n  bin/pulsar standalone\n```\n\n## Building a Producer\nNow that we have set up Pulsar, let's build a producer that publishes messages to a topic. We will first create a `main` function that creates a Pulsar client and produces a message to a topic:\n```rust\nuse pulsar_client::{producer::*, Pulsar, TokioExecutor};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"127.0.0.1:6650\";\n    let pulsar: Pulsar<TokioExecutor> = Pulsar::builder(addr, TokioExecutor)\n        .build()\n        .await?;\n    let producer: Producer<TokioExecutor> = pulsar\n        .producer()\n        .with_topic(\"test-topic\")\n        .build()\n        .await?;\n    producer.send(\"hello, pulsar!\".as_bytes()).await?;\n    Ok(())\n}\n```\n\n## Building a Consumer\nNow, let's build a consumer that consumes messages from a topic. We will use the `async-stream` feature of the `pulsar-client` crate to consume messages continuously:\n```rust\nuse pulsar_client::{consumer::*, ConsumerConfig, Pulsar, TokioExecutor};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let addr = \"127.0.0.1:6650\";\n    let pulsar: Pulsar<TokioExecutor> = Pulsar::builder(addr, TokioExecutor)\n        .build()\n        .await?;\n    let consumer: Consumer<TokioExecutor> = pulsar\n        .consumer()\n        .with_topic(\"test-topic\")\n        .with_consumer_name(\"test-consumer\")\n        .with_consumer_config(ConsumerConfig {\n            subscription_mode: SubscriptionMode::Exclusive,\n            ..Default::default()\n        })\n        .build()\n        .await?;\n    let mut messages = consumer.stream().await?;\n    while let Some(msg) = messages.next().await {\n        println!(\"Received message: {:?}\", msg.payload());\n    }\n    Ok(())\n}\n```\n\n## Conclusion\nIn this tutorial, we have learned how to build a distributed system with Rust and Apache Pulsar. We built a producer that publishes messages to a topic and a consumer that consumes messages continuously. You can modify and extend this code to build other types of distributed systems, such as stream processing systems and event-driven architectures. Happy coding!"
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}