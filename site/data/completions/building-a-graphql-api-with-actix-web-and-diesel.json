{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building a High-Performance HTTP Proxy with Nginx\", \"How to Use Kafka to Build Scalable and Fault-Tolerant Distributed Systems\", \"Advanced Techniques for Using PostgreSQL JSONB Data Type\", \"Writing Secure Rust Code: A Deep Dive into Memory Safety\", \"Fine-tuning BERT for Question Answering - A Step-by-Step Guide\", \"How to Use the Decorator Pattern for Flexible and Extensible Code\", \"A Deep Dive into Multithreading with Clojure\", \"How to Design Reactive Microservices Using Event-Driven Architecture\", \"Writing Efficient SQL Queries: Tips and Tricks\", \"Mastering Connection Pooling in Django\", \"Mastering the Actor Model Concurrency Paradigm in Elixir\", \"How to use Elm to build maintainable, efficient, and bug-free front-end applications\", \"How to Use Generators to Create Infinite Sequences in Python\", \"Building High Performance Distributed Data Pipelines with Apache Flink\", \"Implementing a Consistent Hashing Algorithm in TypeScript\", \"The Event Sourcing Design Pattern in TypeScript\", \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7PrZztsqrkHx4trNgTySn48Dzq2xj",
  "object": "chat.completion",
  "created": 1686398515,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 828,
   "completion_tokens": 1465,
   "total_tokens": 2293
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Building a GraphQL API with Actix-Web and Diesel\n\nTags: Rust, GraphQL, Actix-Web, Diesel\n\nGraphQL is a powerful query language for APIs that allows clients to request exactly the data they need, making it easier to develop APIs that provide flexible and efficient responses. In this tutorial, we will build a GraphQL API using Rust, Actix-Web, and Diesel.\n\n## Prerequisites\n\nTo follow along with this tutorial, you should have a basic understanding of Rust, Actix-Web, and Diesel. You should also have Rust, Cargo, and Diesel installed on your machine.\n\n## Setting up the project\n\nLet's start with creating a new Rust project and adding the necessary dependencies. In the project root directory, create a new file called `Cargo.toml` and put the following code inside:\n\n```toml\n[package]\nname = \"actix-graphql\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\nactix-web = \"3.3.2\"\nactix-rt = \"2.4.1\"\nserde = \"1.0.127\"\nserde_derive = \"1.0.127\"\njuniper = \"0.14.2\"\njuniper_actix = \"0.3.1\"\ndiesel = \"1.4.5\"\ndiesel_derives = \"1.4.1\"\nr2d2 = \"0.8.8\"\nr2d2_diesel = \"1.0.0\"\nqstring = \"0.6.0\"\n```\n\nThen, run the following command to create the `src` directory and the main source file called `main.rs`:\n\n```bash\nmkdir src && touch src/main.rs\n```\n\n## Creating a GraphQL Schema\n\nNext, let's define our GraphQL schema. Create a new file called `schema.graphql` in the project root directory and add the following code:\n\n```graphql\nenum Episode {\n  NEWHOPE\n  EMPIRE\n  JEDI\n}\n\ntype Character {\n  id: ID!\n  name: String!\n  friends: [Character!]\n  appearsIn: [Episode!]!\n}\n\ninput NewCharacterInput {\n  name: String!\n  friends: [ID!]!\n  appearsIn: [Episode!]!\n}\n\ntype Query {\n  characters(ids: [ID!]!): [Character!]!\n}\n\ntype Mutation {\n  createCharacter(input: NewCharacterInput!): Character!\n}\n```\n\nThis schema defines two types: `Character` and `Episode` and two root queries: `Query` and `Mutation`. The `Query` type allows us to retrieve a list of `Character`s given an array of `ID`s, and the `Mutation` type allows us to create a new `Character` using the `NewCharacterInput` input type.\n\n## Defining the Rust types\n\nNext, let's define the Rust types that correspond to the GraphQL types. In the `src/main.rs` file, add the following code:\n\n```rust\n#[macro_use]\nextern crate diesel;\n\nmod models;\nmod schema;\n\nuse actix_web::{web, App, HttpRequest, HttpResponse, HttpServer, Responder, Result};\nuse juniper::*;\nuse juniper_actix::*;\nuse r2d2::Pool;\nuse r2d2_diesel::ConnectionManager;\n\ntype DbPool = Pool<ConnectionManager<diesel::PgConnection>>;\n\n#[derive(Debug)]\nstruct Context {\n    db_pool: DbPool,\n}\n\nimpl juniper::Context for Context {}\n\n#[derive(Clone, Debug, Queryable)]\npub struct Character {\n    pub id: i32,\n    pub name: String,\n}\n\n#[derive(Insertable)]\n#[table_name = \"characters\"]\npub struct NewCharacter<'a> {\n    pub name: &'a str,\n}\n\npub struct QueryRoot;\n\n#[juniper::object(Context = Context)]\nimpl QueryRoot {\n    fn characters(context: &Context, ids: Vec<i32>) -> Vec<Character> {\n        use crate::schema::characters::dsl::*;\n\n        let connection = context.db_pool.get().unwrap();\n        characters.filter(id.eq_any(ids)).load::<Character>(&connection).unwrap()\n    }\n}\n\npub struct MutationRoot;\n\n#[juniper::object(Context = Context)]\nimpl MutationRoot {\n    fn create_character(\n        context: &Context,\n        input: NewCharacterInput,\n    ) -> FieldResult<Character> {\n        use crate::schema::characters;\n\n        let connection = context.db_pool.get().unwrap();\n        diesel::insert_into(characters::table)\n            .values(&NewCharacter { name: &input.name })\n            .get_result(&connection)\n            .map_err(|err| FieldError::new(\"Failed to insert new character\", graphql_value!({ \"error\": err.to_string() })))\n    }\n}\n\nfn main() -> std::io::Result<()> {\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let manager = ConnectionManager::<diesel::PgConnection>::new(database_url);\n    let db_pool = r2d2::Pool::builder().build(manager).unwrap();\n\n    HttpServer::new(move || {\n        let context = Context { db_pool: db_pool.clone() };\n        let schema = std::sync::Arc::new(\n            juniper::RootNode::new(QueryRoot {}, MutationRoot {})\n                .introspection_modifier(|&mut _| {})\n        );\n        App::new()\n            .data(context)\n            .wrap(ContentType::json())\n            .service(\n                web::resource(\"/\")\n                    .route(web::post().to(graphql_handler(schema.clone())))\n                    .route(web::get().to(playground_handler(\"/\"))),\n            )\n    })\n    .bind(\"localhost:8080\")?\n    .run()\n}\n``` \n\nWe start by importing the necessary dependencies, defining the `Context` struct that will hold the database connection pool, and implementing the `juniper::Context` trait. Then, we define the `Character` and `NewCharacter` Rust structs that correspond to the `Character` and `NewCharacterInput` GraphQL types, respectively. \n\nNext, we define the `QueryRoot` and `MutationRoot` types that correspond to the root `Query` and `Mutation` types in our schema, respectively, and implement the corresponding GraphQL resolvers using Diesel to query the database.\n\nFinally, we create the `HttpServer` and define its routes, but instead of handling GraphQL requests directly, we use the `juniper_actix` crate to handle them for us.\n\n## Running the application\n\nTo start the server, create a `.env` file in the root directory and add the following line:\n\n```\nDATABASE_URL=postgres://localhost/actix-graphql\n```\n\nThen, run the following command:\n\n```bash\ncargo run\n```\n\nVisit `http://localhost:8080` to access the GraphQL playground and try running some queries and mutations.\n\n## Conclusion\n\nIn this tutorial, we have built a GraphQL API using Rust, Actix-Web, and Diesel. With this setup, you should be able to build more complex APIs with a powerful and flexible GraphQL query language."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}