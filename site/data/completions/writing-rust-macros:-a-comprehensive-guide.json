{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "Base topics for the blog post off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "system",
   "content": "Use computer code snippets to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Come up with an interesting topic for an advanced level reader that is not related to a previous post and output a post following the rules defined."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line in plain text."
  },
  {
   "role": "user",
   "content": "Include a list of 1 to 3 tags on the last line of the post formatted in plain text as a comma separated list, like:\nTags: <tag1>, <tag2>"
  },
  {
   "role": "user",
   "content": "The post should have multiple sections and should be long in length."
  }
 ],
 "completion": {
  "id": "chatcmpl-7Irm17GdZAxUvk0oU4FOVIuztTX4j",
  "object": "chat.completion",
  "created": 1684730965,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 683,
   "completion_tokens": 1806,
   "total_tokens": 2489
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Writing Rust Macros: A Comprehensive Guide\n\nAre you finding that your Rust code is cluttered and repetitive? Do you want to reduce boilerplate and remove errors from your code? If so, you should start writing Rust macros!\n\nIn this comprehensive guide, we'll cover everything you need to know to get started with writing Rust macros. By the end of this post, you'll have a good idea of how macros work and how to create them. Let's dive in!\n\n## What are Macros?\n\nMacros are a way to write code that writes code. In Rust, macros are used to generate code at compile time, which can significantly reduce boilerplate and improve code quality. Rust macros are different from C or C++ macros, which simply do text substitution.\n\nRust macros are split into two categories: declarative macro and procedural macro. Declarative macros are used to match against patterns and replace them with code. Procedural macros help you transform Rust code at compile time, generate code or reuse existing code with a twist.\n\n## Writing Declarative Macros\n\nDeclarative macros are used to match against patterns and replace them with code. To define a declarative macro, you need to use the `macro_rules!` macro. Here is an example of a simple macro that prints some text:\n\n```rust\nmacro_rules! say_hello {\n    () => {\n        println!(\"Hello!\");\n    };\n}\n\nfn main() {\n    say_hello!();\n}\n```\n\nIn this example, we define a macro called `say_hello!`. In the macro definition, we use the `()` pattern to match an empty invocation. The macro replaces the invocation with the code `println!(\"Hello!\");`. In the main function, we call the macro `say_hello!();`, which generates the code to print `\"Hello!\"`.\n\n### Matching against Patterns\n\nThe power of declarative macros comes from the ability to match against patterns. A pattern is a fragment of code that the macro can match against. A pattern can be a literal, an ident, a repetition, or a complex structure.\n\nHere is an example of a macro that sums two integers:\n\n```rust\nmacro_rules! sum {\n    ( $x:expr, $y:expr ) => {\n        $x + $y\n    };\n}\n\nfn main() {\n    let x = 1;\n    let y = 2;\n    let z = sum!(x, y);\n    println!(\"{}\", z); // prints 3\n}\n```\n\nIn this example, we define a macro called `sum!`. The macro takes two arguments, `x` and `y`, which represent two integers. The macro replaces the invocation with the code `$x + $y;`. In the main function, we call the macro `sum!(x, y);`, and it generates code to sum two integers.\n\n### Conditional Statements\n\nMacros can also include conditional statements to match against multiple patterns. Here is an example of a `match` statement implemented using a macro:\n\n```rust\nmacro_rules! match_expr {\n    ($x:expr, $($($p:pat)|+ $(if $e:expr)? => $r:expr),+ $(,)?) => {\n        match $x {\n            $( $p $(if $e)? => $r, )+\n            _ => {}\n        }\n    };\n}\n\nfn main() {\n    let x = 1;\n    match_expr!(x,\n      1 => println!(\"One\"),\n      2 if 1 + 1 == 2 => println!(\"Two\"),\n      _ => println!(\"Something else\"));\n}\n```\n\nIn this example, we define a macro called `match_expr!`. The macro takes a value `x` and one or more patterns and expressions to match against. The macro replaces the invocation with the code of a `match` statement that matches `x` against the patterns.\n\n## Writing Procedural Macros\n\nProcedural macros are used to transform Rust code at compile time. They're more powerful than declarative macros, but they're also more complex to write. The three types of procedural macros are: attribute macros, function-like macros, and derive macros.\n\n### Attribute Macros\n\nAttribute macros are used to modify a Rust module or item. An attribute macro is defined using the `proc_macro_attribute` attribute macro. Here's an example of an attribute macro that adds a debug print statement to a Rust function:\n\n```rust\nextern crate proc_macro;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_attribute]\npub fn debug(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let mut fun = syn::parse_macro_input!(item as syn::ItemFn);\n\n    let body = &fun.block;\n    let inputs = &fun.decl.inputs;\n    let output = &fun.decl.output;\n\n    let name = &fun.ident;\n\n    fun.block = syn::parse_quote! {{\n        eprintln!(\"[DEBUG] Entering {}\", stringify!(#name));\n        let result = #body;\n        eprintln!(\"[DEBUG] {} result = {:?}\", stringify!(#name), result);\n        result\n    }};\n\n    let res = quote::quote! {\n        #fun\n    };\n\n    res.into()\n}\n\n#[debug]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nfn main() {\n    let a = 2;\n    let b = 3;\n    let c = add(a, b);\n    println!(\"{}\", c);\n}\n```\n\nIn this example, we define a procedural macro called `debug` using the `proc_macro_attribute` attribute macro. This macro takes a Rust function, adds a debug print statement to it, and returns the modified source code. We apply this attribute to the function `add`, which we define later in the code.\n\n### Function-Like Macros\n\nFunction-like macros are used to generate Rust code based on the input arguments. They're defined using the `proc_macro` crate. Here's an example of a function-like macro that implements the `Option` type:\n\n```rust\n#[proc_macro]\npub fn option(input: TokenStream) -> TokenStream {\n    let s = input.to_string();\n    let res = quote::quote! {\n        pub enum Option<T> {\n            None,\n            Some(T),\n        }\n    };\n    res.into()\n}\n\nfn main() {\n    let x: Option<i32> = None;\n    println!(\"{:?}\", x);\n}\n```\n\nIn this example, we define a function-like macro called `option` using the `proc_macro` attribute. This macro generates the code for the `Option` enum with two variants `None` and `Some`. We use this macro to generate an `Option<i32>` variable `x`, which we print.\n\n### Derive Macros\n\nDerive macros are used to generate Rust code based on the implementation of a trait. They're defined using the `proc_macro_derive` attribute macro. Here's an example of a derive macro that generates the implementation of the `Add` trait for a custom struct:\n\n```rust\n#[proc_macro_derive(Add)]\npub fn add_derive(input: TokenStream) -> TokenStream {\n    let ast = syn::parse(input).unwrap();\n    impl_add_macro(&ast)\n}\n\nfn impl_add_macro(ast: &syn::DeriveInput) -> TokenStream {\n    let name = &ast.ident;\n    let expanded = quote::quote! {\n        impl std::ops::Add for #name {\n            type Output = Self;\n            fn add(self, other: Self) -> Self {\n              #name { val: self.val + other.val }\n            }\n        }\n    };\n    TokenStream::from(expanded)\n}\n\n#[derive(Add)]\nstruct MyStruct {\n    val: i32,\n}\n\nfn main() {\n    let a = MyStruct { val: 2 };\n    let b = MyStruct { val: 3 };\n    let c = a + b;\n    println!(\"{:?}\", c);\n}\n```\n\nIn this example, we define a derive macro called `Add` using the `proc_macro_derive` attribute macro. This macro generates the implementation of the `Add` trait for a custom struct with a single field `val`. We use this macro to implement the `Add` trait for `MyStruct` and add two `MyStruct` instances.\n\n## Conclusion\n\nMacros are a powerful feature of the Rust language. They allow for the creation of complex code patterns that can be used to improve the quality, readability, and performance of your code. In this comprehensive guide, we learned about declarative and procedural macros, how to define them, and how to use them to generate Rust code. I hope you find this guide useful in your next Rust project.\n\nTags: Rust, Macros, Procedural Macros, Declarative Macros, Programming Macros, Macro Rules."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}