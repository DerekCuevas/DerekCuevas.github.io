{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\", \"Mastering Browser Storage in TypeScript\", \"Mastering Rust's `std::env::args_os()`\", \"Building Composable, Scalable, and Reusable Redux Reducers\", \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\", \"The Magic of High-Level Streams\", \"Using Rust's Pinning API for Safe and Performant Async Programming\", \"Building Scalable REST APIs with Node.js and PostgreSQL\", \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7Ns0FM3qWPigHnXe9Rkhnchr7PI1d",
  "object": "chat.completion",
  "created": 1685923487,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 819,
   "completion_tokens": 1545,
   "total_tokens": 2364
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building Robust Elixir Back-End APIs with Phoenix Contexts\n\nTags: Elixir, Phoenix, API Design\n\n# Introduction\nWhen building back-end APIs with Elixir and Phoenix, it is important to not only ensure the correctness of the responses but also to make the code easily maintainable and organized. Phoenix is a powerful web framework that provides a robust structure for web applications and APIs, but it can get messy and confusing if not organized properly. In this post, we will explore how to write clean and organized code with Phoenix Contexts, by following the Single Responsibility Principle (SRP) and the Open-Closed Principle (OCP).\n\n# Background\nPhoenix uses a term called `Contexts`, which allows the grouping of functionality into modules, and creates clear boundaries between concerns. Each context is responsible for a single domain of the application and contains all the necessary logic for that domain. By grouping related functionality together, we can ensure that the code is easy to read, testable and maintainable.\n\n# The Problem\nOne of the common problems while building an API with Phoenix is that endpoints can get overcrowded, with multiple concerns in a single file. This makes code management and maintenance difficult. Let us take the following example:\n\n```elixir\ndefmodule MyApp.Web.UserController do\n  use MyApp.Web, :controller\n\n  def index(conn, _params) do\n    users = MyApp.User.list_users()\n    render(conn, \"index.json\", users: users)\n  end\n\n  def create(conn, %{\"user\" => user_params}) do\n    changeset = MyApp.User.registration_changeset(%User{}, user_params)\n\n    case MyApp.Users.create_user(changeset) do\n      {:ok, user} ->\n        conn\n        |> put_status(:created)\n        |> put_resp_header(\"location\", Routes.user_path(conn, :show, user))\n        |> render(\"show.json\", user: user)\n      {:error, changeset} ->\n        conn\n        |> put_status(:unprocessable_entity)\n        |> render(Phoenix.ChangesetView, \"error.json\", changeset: changeset)\n    end\n  end\n  \n  def update(conn, %{\"id\" => id, \"user\" => user_params}) do\n    user = MyApp.User.get_user!(id)\n    changeset = MyApp.User.registration_changeset(user, user_params)\n\n    case MyApp.User.update_user(changeset) do\n      {:ok, user} ->\n        conn\n        |> put_status(:ok)\n        |> render(\"show.json\", user: user)\n      {:error, changeset} ->\n        conn\n        |> put_status(:unprocessable_entity)\n        |> render(Phoenix.ChangesetView, \"error.json\", changeset: changeset)\n    end\n  end\n\n  def delete(conn, %{\"id\" => id}) do\n    user = MyApp.User.get_user!(id)\n    MyApp.User.delete_user(user)\n    conn |> put_status(:no_content) |> send_resp(%{})\n  end\nend\n```\n\nIn the above code, we can see that `UserController` is responsible for user-related endpoints, and contains `index`, `create`, `update`, and `delete` actions. This module also has business logic code for `Users`. In the real world application, it would be impossible to keep things this simplified with more business logic and relationships.\n\n# The Solution: Phoenix Contexts\nPhoenix Contexts help to keep all the business logic and functionality in one place, ensuring that each context contains all the necessary logic for its domain, defined as a module. A context should contain the CRUD functions for domain entities, which conceals the knowledge of the persistence layer from the web layer. \n\nLet's explain how to implement contexts by walking through an example. Let's assume we are building a social networking app and want to only focus on the user-related functionality. We would create a new context module called `MyApp.User` to cleanly incorporate all user-related functions. Within that module, we can create a new file `user.ex` which defines a context module as follows:\n\n```elixir\ndefmodule MyApp.User do\n  alias MyApp.Repo\n  alias MyApp.User\n\n  def list_users() do\n    Repo.all(User)\n  end\n\n  def create_user(attrs \\\\ %{}) do\n    %User{}\n    |> User.changeset(attrs)\n    |> Repo.insert()\n  end\n\n  def update_user(%User{} = user, attrs) do\n    user\n    |> User.changeset(attrs)\n    |> Repo.update()\n  end\n\n  def delete_user(%User{} = user) do\n    Repo.delete(user)\n  end\nend\n```\n\nIn the above definition of the `MyApp.User` context, we define functions for different user-related functionality. `list_users/0` lists all the users in the database, and `create_user/1` creates a user from specified attributes. `update_user/2` function is used to update an existing user, while `delete_user/1` takes in a user and removes it from the database. \n\n# Using the Context in the Controller\nNow instead of defining the functions in `UserController` we can use `MyApp.User` module in the controller as follows:\n\n```elixir\ndefmodule MyApp.Web.UserController do\n  use MyApp.Web, :controller\n  alias MyApp.User\n\n  def index(conn, _params) do\n    users = User.list_users()\n    render(conn, \"index.json\", users: users)\n  end\n\n  def create(conn, %{\"user\" => user_params}) do\n    case User.create_user(user_params) do\n      {:ok, user} ->\n        conn\n        |> put_status(:created)\n        |> put_resp_header(\"location\", Routes.user_path(conn, :show, user))\n        |> render(\"show.json\", user: user)\n      {:error, changeset} ->\n        conn\n        |> put_status(:unprocessable_entity)\n        |> render(\"error.json\", message: \"Failed to create user\")\n    end\n  end\n  \n  def update(conn, %{\"id\" => id, \"user\" => user_params}) do\n    user = User.get_user!(id)\n    \n    case User.update_user(user, user_params) do\n      {:ok, user} ->\n        conn\n        |> put_status(:ok)\n        |> render(\"show.json\", user: user)\n      {:error, changeset} ->\n        conn\n        |> put_status(:unprocessable_entity)\n        |> render(\"error.json\", message: \"Failed to update user\")\n    end\n  end\n\n  def delete(conn, %{\"id\" => id}) do\n    user = User.get_user!(id)\n    User.delete_user(user)\n    conn |> put_status(:no_content) |> send_resp(%{})\n  end\nend\n```\nAs we can see, the controller has been simplified quite a bit, and the Web layer has no knowledge of how the user is stored in the persistence layer. This is achieved via the context's function defined in the above modules. By abstracting the persistence layer, we can change the database structure without affecting the Web Layer.\n\n# Conclusion\nPhoenix Contexts is a powerful, yet simple way to build maintainable and organized APIs when working with the Phoenix framework. By closely following the Single Responsibility Principle, and the Open-Closed Principle, we can ensure a high degree of modularity, reusability, and testability. If you're building a large Phoenix application or API, we highly recommend giving Phoenix Contexts a try."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}