{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\", \"Building Real-Time, High-Performance Applications with Rust and WebSockets\", \"How to Build a Distributed System with Rust and Apache Pulsar\", \"Advanced TypeScript types: Generics with constraints\", \"Building High-Performance IoT Applications with Rust\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LQErwRKpexMDGOwZlSrEUINvyabg",
  "object": "chat.completion",
  "created": 1685340105,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 827,
   "completion_tokens": 856,
   "total_tokens": 1683
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Advanced Elixir: Scenic, a Great UI Library\n\nTags: Elixir, UI, Scenic\n\nIf you need to build a User Interface that runs perfectly on embedded systems, desktop, mobile, or web environments, Scenic is an excellent choice for your project. Scenic is an open-source library that enables the fast and efficient development of composable and responsive graphical user interfaces in Elixir.\n\n### Introduction to Scenic\n\nScenic is a minimalistic, simple, and lightweight framework for building User Interface components. It offers high-performance rendering and a declarative approach to create views based on the model view controller paradigm. Its design allows for easy composition, layout arrangement, and data-driven view updates.\n\nScenic offers a handful of built-in Widgets, enabling you to start building your UI as if they're already up and running. It features text views, images, buttons, sliders, list views, etc. You can also create custom widgets that encapsulate navigation, communication with backends, or handling complex user interactions. Scenic follows the single responsibility principle, focuses heavily on composition, and delivers a powerful event delegation system.\n\n### How to Use Scenic\n\nTo build a Scenic UI, you need to first install the Scenic library into your Elixir project. Scenic can be added to your project by adding the following dependency to your `mix.exs` file:\n\n```elixir\ndef deps do\n  [{:scenic, \"~> 0.11\"}]\nend\n```\n\nOnce you've installed Scenic, you can start building your UI. Here is an example of how you can create a simple Scenic app that features a button:\n\n```elixir\ndefmodule MyApp.App do\n  use Scenic.App\n  use Scenic.Ui\n\n  def handle_input(event, _state) do\n    case event do\n      :down -> Scenic.run(:quit)\n      _ -> :noop\n    end\n  end\n\n  def draw(state, _opts) do\n    clear()\n    fill_color(:red)\n    rectangle(100, 100, 200, 100)\n    fill()\n\n    mix = ref(1)\n    decrementer = fn() -> mix.(\"dec\") end\n    incrementer = fn() -> mix.(\"inc\") end\n\n    leading = static_text(10, 10, \"Click the button to increment a counter\")\n    button = button(20, 80, \"Click to Increment Counter\\nCurrent Count: #{mix.()}\",\n                    on_click: incrementer)\n\n    container(leading)\n    container(button)\n  end\nend\n```\n\nIn the example, you extended two key Scenic modules: `Scenic.App` and `Scenic.Ui`. You then defined an `handle_input/2` function to handle button events and implemented the `draw/2` function to create the app window, declare the layout, and add a button widget to it.\n\nAfter you've built your app, you can run it via Scenic's CLI by executing the following command:\n\n```elixir\nmix scenic.run MyApp.App\n```\n\n### Benefits of Scenic\n\nScenic's biggest benefit is that it brings to the surface the fast and secure concurrency engine that Elixir has. Unlike other UI libraries that encourage mutable state, Scenic's emphasis on composition and visualization promotes functional thinking that can help reduce parallel programming bugs frequently caused by race conditions. Scenic is intended for use on hardware where performance is crucial, and its rendering engine is designed for low latency and high performance.\n\nScenic's capabilities make it a great solution for building real-time and mission-critical systems that must run on embedded devices. Its ability to update UI elements at a high frequency also makes it suitable for creating applications that are latency-sensitive, such as trading or financial applications.\n\n### Conclusion\n\nIf you're looking for an elegant, high-performance, and solid UI library that benefits from Elixir's language features, Scenic is worth looking into. Its capabilities make it an excellent choice for building UI for any system, regardless of the environment. As Elixir's ecosystem grows, we can expect Scenic to continue to adapt and improve, streamlining the development process even further."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}