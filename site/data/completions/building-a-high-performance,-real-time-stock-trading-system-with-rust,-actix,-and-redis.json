{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "Base topics for the blog post off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\", \"Securely Storing Secrets in Rust\", \"How to Write High Performance Elm Code with the Help of Web Workers\", \"The Ultimate Guide to Building and Optimizing GraphQL APIs with Node.js\", \"Building High-Performance Reactive Applications with Rust and Tokio\", \"Mastering GraphQL's Execution Phase with Node.js, TypeScript, and TypeGraphQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "system",
   "content": "Use computer code snippets to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Come up with an interesting topic for an advanced level reader that is not related to a previous post and output a post following the rules defined."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line in plain text."
  },
  {
   "role": "user",
   "content": "Include a list of 1 to 3 tags on the last line of the post formatted in plain text as a comma separated list, like:\nTags: <tag1>, <tag2>"
  },
  {
   "role": "user",
   "content": "The post should have multiple sections and should be long in length."
  }
 ],
 "completion": {
  "id": "chatcmpl-7JhU5pKorjHRjpwHcY2I2HN1sg3eV",
  "object": "chat.completion",
  "created": 1684929741,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 769,
   "completion_tokens": 2130,
   "total_tokens": 2899
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building a High-Performance, Real-time Stock Trading System with Rust, Actix, and Redis\n\nIn today's world, stock trading is a highly dynamic and real-time process that requires speed, scalability, and fault-tolerance. In this blog post, we'll dive into the details of building a high-performance, real-time, stock trading system using Rust, Actix, and Redis. This post is advanced level, and assumes a strong understanding of Rust, Actix, and Redis.\n\n## Designing the Architecture of the Stock Trading System\n\nBefore we begin writing any code, we need to think about the architecture of our stock trading system. Our system needs to be highly scalable, fault-tolerant, and capable of handling a large number of concurrent connections. To achieve this, we'll take a microservices-based architecture approach, where services are responsible for a specific task and communicate with each other over a message bus.\n\nThe stock trading system can be divided into four main components:\n\n1. Price Feed Service - This service is responsible for providing real-time stock price data to other services.\n2. Order Management Service - This service handles all orders received from traders and executes them against the available stock.\n3. Account Management Service - This service is responsible for managing trader accounts, including account balances and holdings.\n4. Web Socket Service - This service enables real-time communication between traders and the server.\n\nTo implement real-time communication, we'll use the Redis pub/sub feature to broadcast stock prices and order execution events to all connected clients.\n\n## Implementing the Services in Rust using Actix\n\nNow that we have a clear understanding of our architecture, we can begin implementing our services. We'll use Rust with Actix, a high-performance, actor-based web framework that is ideal for building microservices.\n\n### Price Feed Service\n\nThe price feed service is responsible for providing real-time stock price data, which other services consume. We'll use Actix's built-in WebSocket functionality to send real-time updates to connected clients.\n\n```\n// Define a WebSocket actor\nstruct PriceFeed {\n    price: f64,\n}\n\nimpl Actor for PriceFeed {\n    type Context = ws::WebsocketContext<Self>;\n\n    fn started(&mut self, ctx: &mut Self::Context) {\n        // start the price feed loop\n        ctx.run_interval(Duration::from_secs(1), |act, ctx| {\n            // update the price randomly\n            act.price = (100.0 + rand::random::<f64>() * 20.0).round_to(2);\n\n            // broadcast the new price to all clients\n            ctx.text(format!(\"{}\", act.price));\n        });\n    }\n}\n\n// Define WebSocket route\nasync fn price_feed_route(r: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {\n    ws::start(PriceFeed { price: 0.0 }, &r, stream)\n}\n```\n\n### Order Management Service\n\nThe order management service is responsible for executing orders received from traders against the available stock. We'll use Redis pub/sub to broadcast order execution events to all connected clients.\n\n```\n// Define an order execution actor\nstruct OrderExecution {\n    price: f64,\n    stock: f64,\n    clients: Vec<Recipient<String>>,\n}\n\nimpl Actor for OrderExecution {\n    type Context = Context<Self>;\n\n    fn started(&mut self, ctx: &mut Self::Context) {\n        // subscribe to the Redis pub/sub channel for order execution events\n        let mut con = redis::Client::open(\"redis://127.0.0.1/\").unwrap().get_connection().unwrap();\n        let mut pubsub = con.as_pubsub();\n        pubsub.subscribe(\"order_executed\").unwrap();\n\n        // start the order execution loop\n        ctx.run_interval(Duration::from_secs(1), |act, _ctx| {\n            // execute orders randomly\n            if rand::random::<bool>() {\n                let executed_price = (100.0 + rand::random::<f64>() * 20.0).round_to(2);\n                let executed_stock = act.stock - rand::random::<f64>() * 10.0;\n                act.price = executed_price;\n                act.stock = executed_stock;\n\n                // broadcast the order execution event to all clients\n                act.clients.iter().for_each(|client| {\n                    client.do_send(format!(\"Order executed: price={} stock={}\", executed_price, executed_stock));\n                });\n\n                // publish the order execution event to Redis pub/sub channel\n                let mut con = redis::Client::open(\"redis://127.0.0.1/\").unwrap().get_connection().unwrap();\n                let _ = con.publish(\"order_executed\", format!(\"price={} stock={}\", executed_price, executed_stock));\n            }\n        });\n    }\n}\n\n// Define the order execution route\nasync fn order_execution_route(data: web::Data<AppState>) -> impl Responder {\n    let (tx, rx) = mpsc::unbounded();\n    let mut addresses = data.order_execution_addresses.lock().unwrap();\n    addresses.push(tx);\n    drop(addresses);\n\n    HttpResponse::Ok().body(\"\")\n}\n```\n\n### Account Management Service\n\nThe account management service is responsible for managing trader accounts, including account balances and holdings. We'll use Redis as our database to store account balances and holdings.\n\n```\n// Define an account actor\nstruct Account {\n    id: u64,\n    balance: f64,\n    stock: f64,\n}\n\nimpl Account {\n    async fn load(id: u64) -> Option<Self> {\n        // load the account data from Redis\n        let mut con = redis::Client::open(\"redis://127.0.0.1/\").unwrap().get_connection().unwrap();\n        let account_data: Option<String> = redis::cmd(\"GET\").arg(format!(\"account:{}\", id)).query(&mut con).ok();\n\n        // parse the account data and return an Account object\n        if let Some(data) = account_data {\n            let parts: Vec<&str> = data.split(',').collect();\n            if parts.len() == 2 {\n                let balance = parts[0].parse().ok()?;\n                let stock = parts[1].parse().ok()?;\n                return Some(Self { id, balance, stock });\n            }\n        }\n\n        None\n    }\n\n    async fn save(&self) {\n        // save the account data to Redis\n        let mut con = redis::Client::open(\"redis://127.0.0.1/\").unwrap().get_connection().unwrap();\n        let _ = redis::cmd(\"SET\").arg(format!(\"account:{}\", self.id)).arg(format!(\"{},{}\", self.balance, self.stock)).query_async(&mut con).await;\n    }\n}\n\n// Define the account management route\nasync fn account_route(id: web::Path<u64>, data: web::Data<AppState>) -> impl Responder {\n    if let Some(mut account) = Account::load(*id).await {\n        // handle account update request\n        if let Ok(params) = web::Query::<HashMap<String, f64>>::from_query(&data).await {\n            if let Some(balance) = params.get(\"balance\") {\n                account.balance = *balance;\n            }\n            if let Some(stock) = params.get(\"stock\") {\n                account.stock = *stock;\n            }\n            account.save().await;\n        }\n\n        // return account info\n        HttpResponse::Ok().body(format!(\"Account: id={}, balance={}, stock={}\", account.id, account.balance, account.stock))\n    } else {\n        HttpResponse::NotFound().body(\"\")\n    }\n}\n```\n\n### Web Socket Service\n\nThe web socket service is responsible for enabling real-time communication between traders and the server. We'll use Actix's built-in WebSocket functionality and Redis pub/sub to broadcast stock prices and order execution events to all connected clients.\n\n```\n// Define a WebSocket actor\nstruct WebSocket {\n    recipient: Option<Recipient<String>>,\n}\n\nimpl Actor for WebSocket {\n    type Context = ws::WebsocketContext<Self>;\n\n    fn started(&mut self, ctx: &mut ws::WebsocketContext<Self>) {\n        // subscribe to the Redis pub/sub channel for price updates and order execution events\n        let mut con = redis::Client::open(\"redis://127.0.0.1/\").unwrap().get_connection().unwrap();\n        let mut pubsub = con.as_pubsub();\n        pubsub.subscribe(\"price_update\").unwrap();\n        pubsub.subscribe(\"order_executed\").unwrap();\n    \n        // start receiving WebSocket messages\n        self.recipient = Some(ctx.address().recipient());\n    }\n    \n    fn stopped(&mut self, ctx: &mut ws::WebsocketContext<Self>) {\n        // unsubscribe from the Redis pub/sub channels\n        let mut con = redis::Client::open(\"redis://127.0.0.1/\").unwrap().get_connection().unwrap();\n        let mut pubsub = con.as_pubsub();\n        pubsub.unsubscribe(\"price_update\").unwrap();\n        pubsub.unsubscribe(\"order_executed\").unwrap();\n    \n        // remove the recipient from the list of WebSocket clients\n        data.clients.lock().unwrap().remove(&ctx.address().recipient());\n    }\n}\n\n// Define WebSocket route\nasync fn websocket_route(r: HttpRequest, stream: web::Payload, data: web::Data<AppState>) -> Result<HttpResponse, Error> {\n    let (tx, rx) = mpsc::unbounded();\n    data.clients.lock().unwrap().insert(tx);\n    let websocket = WebSocket { recipient: None };\n    let resp = ws::start(websocket, &r, stream)?;\n    let mut websocket = resp.0;\n\n    tokio::spawn(async move {\n        while let Some(msg) = rx.recv().await {\n            if let Ok(Some(client)) = websocket.recipient.as_ref().map(|x| x.try_send(msg)) {\n                if let Err(_disconnected) = client {}\n            }\n        }\n    });\n\n    Ok(resp)\n}\n```\n\n## Conclusion\n\nIn this post, we've built a microservices-based architecture for a high-performance, real-time, stock trading system. We've used Rust with Actix to implement the various services, and Redis to enable real-time communication and database storage. By following best practices, we've ensured a highly scalable, fault-tolerant, and fast system architecture that can handle a large number of concurrent connections.\n\nTags: Rust, Actix, Redis"
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}