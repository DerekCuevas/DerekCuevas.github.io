{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "Base topics for the blog post off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "system",
   "content": "Use computer code snippets to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Come up with an interesting topic for an advanced level reader that is not related to a previous post and output a post following the rules defined."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line in plain text."
  },
  {
   "role": "user",
   "content": "Include a list of 1 to 3 tags on the last line of the post formatted in plain text as a comma separated list, like:\nTags: <tag1>, <tag2>"
  },
  {
   "role": "user",
   "content": "The post should have multiple sections and should be long in length."
  }
 ],
 "completion": {
  "id": "chatcmpl-7IrvNrKoc2EcjcYkAnSYOup0HFpL9",
  "object": "chat.completion",
  "created": 1684731545,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 692,
   "completion_tokens": 1099,
   "total_tokens": 1791
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building a Real-Time OCR System with React, Tesseract.js, and WebSockets\n\nHave you ever wanted to build a real-time Optical Character Recognition (OCR) system that can recognize text from incoming video or image streams? In this post, we'll explore how to build an OCR system using React, Tesseract.js, and WebSockets. \n\n## Introduction\nOptical Character Recognition, also known as OCR, is the process of electronically extracting text from images or video. OCR is widely used in document processing, photo tagging, and captioning. A real-time OCR system can process incoming images or video streams and produce text that can be used in a variety of applications. In this post, we'll explore how to build a real-time OCR system that can recognize text from incoming video or image streams using React, Tesseract.js, and WebSockets.\n\n## Prerequisites\nBefore we get started, make sure you have the following installed:\n\n- Node.js (version 12 or higher)\n- Git\n\n## Getting Started\nFirst, let's create a new React app using create-react-app.\n\n```shell\nnpx create-react-app ocr-demo\ncd ocr-demo\n```\n\nNext, we need to install some additional dependencies:\n\n```shell\nnpm install react-webcam tesseract.js sockjs-client --save\n```\n\nWe'll be using the \"react-webcam\" library to capture video frames, the \"tesseract.js\" library to perform OCR, and the \"sockjs-client\" library to send data over WebSockets.\n\n## Creating a Webcam Component\nWe'll add a simple Webcam component that displays the video feed from the webcam. The Webcam component will allow us to capture frames and send them to the server for processing.\n\n```jsx\nimport React, { useRef } from 'react';\nimport Webcam from \"react-webcam\";\n\nconst WebcamCapture = (props) => {\n  const webcamRef = useRef(null);\n\n  const capture = React.useCallback(() => {\n      const imageSrc = webcamRef.current.getScreenshot();\n      props.onCapture(imageSrc);\n    },\n    [webcamRef, props.onCapture]\n  );\n\n  return (\n    <div>\n      <Webcam\n        audio={false}\n        ref={webcamRef}\n        screenshotFormat=\"image/jpeg\"\n      />\n      <button onClick={capture}>Capture photo</button>\n    </div>\n  );\n};\n\nexport default WebcamCapture;\n```\n\nThe \"onCapture\" function will be called when the user clicks the \"Capture photo\" button, passing the captured image as an argument.\n\n## Setting up the Server\nWe'll create an Express server that will handle incoming WebSocket connections. The server will listen for incoming frames, perform OCR using Tesseract.js, and send the text back to the client over WebSockets.\n\n```javascript\nconst express = require('express');\nconst path = require('path');\nconst SockJS = require('sockjs');\n\nconst Tesseract = require('tesseract.js');\n\nconst server = express();\n\n// Serve the static files\nserver.use(express.static(path.join(__dirname, 'build')));\n\n// Set up a WebSocket server\nconst sockjs = require('sockjs');\nconst echo = sockjs.createServer();\necho.on('connection', function(conn) {\n  console.log('Client connected');\n\n  conn.on('data', async function(frame) {\n    try {\n      const image = new Image();\n      image.src = frame;\n\n      const { data: { text } } = await Tesseract.recognize(image);\n      console.log(`Recognized text: ${text}`);\n\n      conn.write(text);\n    } catch (err) {\n      console.error(err);\n    }\n  });\n\n  conn.on('close', function() {\n    console.log('Client disconnected');\n  });\n});\necho.installHandlers(server.listen(8081, '0.0.0.0', function() {\n  console.log('WebSocket server listening on port 8081');\n}));\n```\n\n## Creating the Client\nFinally, we'll create a simple client that connects to the server using WebSockets, captures frames from the webcam, and sends them to the server for processing.\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport SockJS from 'sockjs-client';\nimport WebcamCapture from './WebcamCapture';\n\nconst SOCKET_SERVER_URL = 'http://localhost:8081';\nconst sock = new SockJS(SOCKET_SERVER_URL);\n\nfunction App() {\n  const [text, setText] = useState('');\n\n  useEffect(() => {\n    sock.onmessage = function(e) {\n      setText(e.data);\n    };\n  }, []);\n\n  const handleCapture = (frame) => {\n    sock.send(frame);\n  };\n\n  return (\n    <div className=\"App\">\n      <WebcamCapture onCapture={handleCapture} />\n      {text && (\n        <div className=\"OCR-output\">\n          <h3>OCR Output:</h3>\n          {text}\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## Conclusion\nIn this post, we explored how to build a real-time OCR system using React, Tesseract.js, and WebSockets. We learned how to capture frames from a webcam, perform OCR on the frames using Tesseract.js, send the text back to the client over WebSockets, and display the text on the client.\n\nTags: React, OCR, WebSockets"
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}