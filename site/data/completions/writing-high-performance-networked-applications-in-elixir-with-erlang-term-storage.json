{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\", \"Securely Storing Secrets in Rust\", \"How to Write High Performance Elm Code with the Help of Web Workers\", \"The Ultimate Guide to Building and Optimizing GraphQL APIs with Node.js\", \"Building High-Performance Reactive Applications with Rust and Tokio\", \"Mastering GraphQL's Execution Phase with Node.js, TypeScript, and TypeGraphQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader. Ensure that the topic is not related to a previous post. Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Explain information and details in the post step by step."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7JyKRSWUmmWDTWqRTaWFoHIEJTmLO",
  "object": "chat.completion",
  "created": 1684994491,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 810,
   "completion_tokens": 747,
   "total_tokens": 1557
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Writing High-Performance Networked Applications in Elixir with Erlang Term Storage\n\nTags: Elixir, Erlang Term Storage, Realtime Systems, Distributed Systems, Networking\n\nElixir is a highly scalable programming language that excels at building realtime, distributed systems. One of the key strengths of Elixir comes from its use of the Erlang virtual machine, which has a built-in key-value store called Erlang Term Storage (ETS). ETS is a powerful tool for building high-performance networked applications in Elixir. In this article, we will explore the use of ETS in Elixir and its applications in building networked applications.\n\n## What is Erlang Term Storage\n\nErlang Term Storage is a built-in key-value storage mechanism in the Erlang virtual machine. It is a persistent, distributed storage system that can be used to store large amounts of data in memory. ETS provides a fast, efficient way to store data that can be accessed from multiple processes in a highly concurrent environment.\n\nAn ETS table is created by calling the ETS `new` function. The function takes a name, a set of options, and a list of tuples that define the schema of the table.\n\n```elixir\n:ets.new(:my_table, [:named_table, :set, :public])\n```\n\nHere we create a new ETS table called my_table with options. The options list specifies that the table should be named, be a set, and be public.\n\nETS tables can be accessed from anywhere in an Elixir or Erlang program using the table's name and key.\n\n## Using Erlang Term Storage for Networking\n\nErlang Term Storage can be a valuable tool for building networked applications in Elixir. When building a networked application, it is often important to be able to store data that can be accessed from multiple processes. ETS provides a simple, efficient way to do this.\n\nSuppose, for example, that we are building a chat application in Elixir. We might use an ETS table to store the list of users who are currently connected to the chat server. The list of users can be stored as a set of tuples, where each tuple contains the user's name and the process ID of the process that is handling the user's connection to the chat server.\n\n```elixir\n:ets.new(:connected_users, [:named_table, :set, :public])\n\nuser1_pid = spawn_link(fn -> handle_user_connection(name1, socket1) end)\nuser2_pid = spawn_link(fn -> handle_user_connection(name2, socket2) end)\n...\n:ets.insert(:connected_users, {name1, user1_pid})\n:ets.insert(:connected_users, {name2, user2_pid})\n...\n```\n\nHere, we create a new ETS table called `connected_users` that stores the names and process IDs of connected users. We then spawn two new processes, passing in the user's name and socket for each. Finally, we insert the user and process IDs into the `connected_users` ETS table.\n\nHaving this information in an ETS table allows us to access it from any process in the chat server. This makes it easy to write code that depends on this data, such as broadcasting messages to connected users or sending private messages between users.\n\n## Conclusion\n\nIn this article, we explored how ETS can be used to build high-performance networked applications in Elixir. ETS provides a simple, efficient way to store data that can be accessed from multiple processes in a highly concurrent environment. By leveraging the power of Erlang Term Storage, we can write performant, distributed applications that are easy to reason about and maintain."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}