{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\", \"Building Real-Time, High-Performance Applications with Rust and WebSockets\", \"How to Build a Distributed System with Rust and Apache Pulsar\", \"Advanced TypeScript types: Generics with constraints\", \"Building High-Performance IoT Applications with Rust\", \"Secret Management in Multi-Cloud Kubernetes Environments: A Comprehensive Guide\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LN55KS7hNsvPx68qDijN8RVznTRz",
  "object": "chat.completion",
  "created": 1685327967,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 830,
   "completion_tokens": 1058,
   "total_tokens": 1888
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building Robust Applications with Function Composition in Clojure\n\nTags: Clojure, Functional Programming, Function Composition\n\n\nFunctional programming has gained a lot of attention in software engineering over the years, including the usage of first-class functions, immutable data structures, and function composition. Function composition is a powerful technique often utilized in functional programming languages and is considered a fundamental building block of many functional programming paradigms. Clojure is a popular functional programming language that encourages the use of function composition in building robust, flexible, and maintainable software. In this post, we will explore function composition in Clojure.\n\n## What is Function Composition?\n\nFunction composition is the act of combining two or more functions to create a new function. It is the process of running a function on the output of another function. The output of one function becomes the input of another function, and the result is a new function that performs the combination of the two functions. The output of the second function can then be used as input to a third function, and so on. This chaining of functions forms a pipeline that can be used for more complex computations.\n\n## Function Composition in Clojure\n\nIn Clojure, we combine functions using the `comp` function. The `comp` function takes two or more functions and returns a new function that performs the composition of those functions. The following code illustrates how to use the `comp` function in Clojure.\n\n\n```clojure\n(defn add [x y]\n  (+ x y))\n\n(defn square [x]\n  (* x x))\n\n(defn add-square [x y]\n  (-> (comp square add)\n      (#(% x y))))\n\n\n(add-square 2 3) ; 25\n```\n\nIn the example above, we have three functions - `add`, `square`, and `add-square`. The `add-square` function is built by composing the `add` and `square` functions. The `->` macro in Clojure makes function composition more elegant and concise. The `comp square add` returns a new function that first applies the `add` function and then applies the `square` function to its output. We then pass the result as input to `#(% x y)`, which is an anonymous function that takes two arguments and applies the composed function to those arguments.\n\n## Use Cases of Function Composition\n\nFunction composition has many use cases in Clojure. Some of the most common applications of function composition are:\n\n### Data Transformation\n\nFunction composition can be used to transform data from one format to another, such as converting a string to uppercase or lower case, or converting a map to a vector. The following code illustrates how to use function composition to convert a list of strings to uppercase.\n\n\n```clojure\n(defn to-upper [s]\n  (-> s\n      .toUpperCase))\n\n(defn list-to-upper [lst]\n  (map (comp to-upper str) lst))\n\n(list-to-upper [\"hello\" \"world\"]) ;[\"HELLO\" \"WORLD\"]\n```\n\nIn the example above, `to-upper` function takes a single string argument and returns the uppercase version of the string. The `list-to-upper` function takes a sequence of strings, applies the `to-upper` function using composition with `str` from the standard library, and converts each string in the sequence to uppercase.\n\n### Error Handling\n\nFunction composition can be used to build an error-handling mechanism when dealing with potentially risky operations, such as database queries or network requests. In Clojure, we can use `try/catch` to handle errors. \n\n```clojure\n(defn safe-read-file [path]\n  (try\n    (slurp path)\n    (catch Exception e\n      (println \"An error occurred while reading file\"))))\n\n(defn get-user-info [db id]\n  (->> (str \"SELECT * FROM user WHERE id=\" id)\n       (safe-read-file db)\n       (parse-json)\n       (get-in [\"data\" \"user-info\"])))\n```\n\nIn the example above, `safe-read-file` function takes a path to a file and uses `slurp` to read the file. We wrap the `slurp` function in a `try/catch` block to handle errors gracefully when an exception is thrown. The `get-user-info` function composes multiple functions to retrieve user information from a database. The function first creates a SQL query using the `str` function and the user's id. It then passes the query to `safe-read-file`, which returns the contents of the file located at the path specified. If an error occurs during the reading, a response message is printed to the console, but the function does not crash. Finally, the content of the file is passed to JSON parsing function and retrieves user information from the parsed data.\n\n## Conclusion\n\nFunction composition is a critical programming tool in Clojure that helps create code that is more modular, flexible, and reusable. It is useful when creating insulator functions, building error-handling mechanisms, and transforming data between different formats. By utilizing function composition, we can improve our code's readability and make it more functional, fault-tolerant and easy to maintain in the long run."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}