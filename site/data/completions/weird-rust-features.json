{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\", \"Building Real-Time, High-Performance Applications with Rust and WebSockets\", \"How to Build a Distributed System with Rust and Apache Pulsar\", \"Advanced TypeScript types: Generics with constraints\", \"Building High-Performance IoT Applications with Rust\", \"Secret Management in Multi-Cloud Kubernetes Environments: A Comprehensive Guide\", \"Building a Fault-Tolerant Distributed System with Rust\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LN1SqWZCeleFgNIW5gIbsoU6vGdC",
  "object": "chat.completion",
  "created": 1685327742,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 836,
   "completion_tokens": 704,
   "total_tokens": 1540
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Weird Rust Features\n\nTags: Rust, Programming, Advanced\n\nRust is well known for its memory-safe features, speed, concurrency, and structural readability. However, there are some features in Rust that are lesser known and can seem weird to inexperienced Rustaceans. In this article, we will explore some of these features and their use cases.\n\n## 1. Raw Pointers\n\nRaw pointers in Rust are pointers that are not forced to follow all the borrowing rules, unlike references, which must obey the borrowing rules. Raw pointers can be dereferenced without the borrow checker's permission and are marked with an asterisk followed by the const or mut keywords. Raw pointers to mut data are considered unsafe and cannot be aliased.\n\nHere's an example of creating and dereferencing a raw pointer:\n\n```rust\nlet mut num = 5;\nlet ptr = &num as *const i32;\n\nunsafe {\n    println!(\"Value of num is: {}\", *ptr);\n}\n```\n\nIn the above example, we created a raw pointer `ptr` to the `num` variable and dereferenced it using the `*` operator inside an `unsafe` block. The program prints `Value of num is: 5`.\n\nRaw pointers come in two flavors: `*const T` and `*mut T`, where `T` is the type of value the pointer points to.\n\n## 2. Keyword Paths\n\nRust provides a unique feature where we can use keywords as path components. Using keyword paths gives us access to otherwise hidden functions, for example, to use a function that is overridden by a local definition, without having to use a fully qualified name.\n\nThe special syntax for using a keyword path component is to prefix the component with `r#`. Here's an example:\n\n```rust\nfn r#match() {\n    println!(\"This is not a match expression\");\n}\n\nfn main() {\n    r#match();\n}\n```\n\nIn the above example, we defined a function called `match` using the `r#match` syntax to use a Rust keyword. We are then able to call this function using the `r#match()` syntax.\n\n## 3. Dynamically Sized Types\n\nDynamically sized types (DSTs) are types whose size is unknown at compile time, and allocate memory on the heap. In Rust, DSTs are only allowed behind a pointer or a reference. This means that the bare DST would be unallocated and have no size. \n\nAn example of a dynamically sized type in Rust is a slice of `str` values. The size of a slice is not known at compile-time.\n\nHere’s an example of using a slice with dynamically sized types:\n\n```rust\nlet str_slice: &[str] = &[\"Learn\", \"Rust\"];\nprintln!(\"The slice has a length of {}.\", str_slice.len());\n```\n\nIn the above example, we defined a slice of `str` that is determined at runtime, and accessed its length with the `len()` method. \n\n## Conclusion\n\nRust’s feature set is expansive, and it’s not uncommon for developers to discover new features years after they first started using the language. In this article, we looked at some of the more peculiar Rust features. Raw pointers, keyword paths, and dynamically sized types represent powerful capabilities that Rust offers its users. By being aware of these features and how to use them safely, Rust programmers can take full advantage of the language's capabilities."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}