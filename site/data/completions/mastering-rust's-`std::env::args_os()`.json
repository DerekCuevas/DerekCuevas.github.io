{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building Composable, Scalable, and Reusable Redux Reducers\", \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\", \"The Magic of High-Level Streams\", \"Using Rust's Pinning API for Safe and Performant Async Programming\", \"Building Scalable REST APIs with Node.js and PostgreSQL\", \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7NEcY4kHwbxHN2ACIYNKxGYJZa4b8",
  "object": "chat.completion",
  "created": 1685772102,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 807,
   "completion_tokens": 1036,
   "total_tokens": 1843
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Mastering Rust's `std::env::args_os()`\n\nTags: Rust, Command-line Interface, CLI\n\nHave you ever used the `args` function in Rust to parse command-line arguments? If so, you might be interested in its counterpart, `args_os`, which exposes the program's arguments as a collection of `OsString`s instead of `String`s. In this post, we will dive deep into Rust's `std::env::args_os` function and explore why, how, and when you should use it.\n\n## Overview\n\nThe `args_os` function returns an iterator over the command-line arguments available to a Rust program. Unlike its `args` counterpart, it provides the list of arguments as a collection of `OsString` values, which represent platform-specific, arbitrary byte sequences, rather than `String` values.\n\n```rust\nuse std::env;\n\nfn main() {\n    let args_os: Vec<_> = env::args_os().collect();\n    println!(\"{:?}\", args_os);\n}\n```\n\nRunning this example with the command-line input `rust program.rs --flag` would output `[\"rust\", \"program.rs\", \"--flag\"]` on most platforms.\n\n## Advantages\n\nUsing `args_os` instead of `args` provides several advantages in command-line interface (CLI) applications.\n\nFirstly, it ensures that arguments containing invalid Unicode sequences or sequences incompatible with the current platform's character encoding do not cause a panic, which can occur when passing invalid UTF-8 data to `String`. Instead, it may be desirable to handle encoding errors by replacing the invalid bytes with a fallback or ignoring them entirely.\n\n```rust\nuse std::env;\nuse std::ffi::{OsStr, OsString};\nuse std::os::unix::ffi::{OsStrExt, OsStringExt};\n\nfn main() {\n    let invalid_arg = OsString::from_vec(vec![0xff]);\n    let args_os: Vec<_> = env::args_os()\n        .map(|arg| {\n            arg.encode_wide()\n                .filter(|&ch| ch <= 0x7f)\n                .map(|ch| ch as u8)\n                .chain(std::iter::once(0))\n                .collect::<Vec<_>>()\n        })\n        .map(|arg| OsString::from_vec(arg))\n        .chain(std::iter::once(invalid_arg))\n        .collect();\n    println!(\"{:?}\", args_os);\n}\n```\n\nThis program replaces any non-ASCII byte with a question mark, converting `\"Rücksendung\"` into `\"R?cksendung\"`, for example. It also adds an invalid argument consisting of the invalid byte `0xff` to demonstrate that `args_os` does not panic when encountering non-UTF-8 sequences.\n\nSecondly, it enables you to retain the original byte sequence of the argument, which is useful when working with filenames, environment variables, system-specific flags, and other non-Unicode data.\n\n```rust\nuse std::env;\nuse std::ffi::{OsStr, OsString};\nuse std::os::unix::ffi::OsStrExt;\n\nfn main() {\n    let args_os: Vec<_> = env::args_os()\n        .map(|arg| {\n            arg.as_bytes()\n                .iter()\n                .filter(|&&ch| ch != b' ')\n                .map(|&ch| ch)\n                .collect::<Vec<_>>()\n        })\n        .map(|arg| OsString::from_vec(arg))\n        .collect();\n    println!(\"{:?}\", args_os);\n}\n```\n\nThis program removes every space character of the input arguments and prints the result without converting the byte sequence to a `String`, ensuring that non-ASCII, non-UTF-8 characters are preserved.\n\nFinally, it enables you to preserve any zero bytes in the input, which are otherwise treated as a null terminator when converted to `String`.\n\n```rust\nuse std::env;\nuse std::ffi::OsString;\nuse std::os::unix::ffi::OsStringExt;\n\nfn main() {\n    let args_os: Vec<_> = env::args_os()\n        .map(|arg| {\n            let mut os_string = arg.into_os_string();\n            os_string.push(\"\\0\");\n            os_string\n        })\n        .collect();\n    println!(\"{:?}\", args_os);\n}\n```\n\nThis program appends a null byte to each input argument, ensuring that zero bytes are preserved in the output.\n\n## Conclusion\n\nIn this post, we have explored the `std::env::args_os` function in Rust, which provides access to the command-line arguments of a program as collations of `OsString` values, preserving non-ASCII, non-UTF-8, and zero bytes in the input. We have demonstrated how this function can be used to handle invalid Unicode sequences, work with non-Unicode data, and preserve zero bytes. Whether you are building a CLI application, working with filenames, or dealing with platform-specific flags, `args_os` is a powerful tool to have at your disposal."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}