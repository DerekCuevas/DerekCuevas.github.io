{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building High Performance Distributed Data Pipelines with Apache Flink\", \"Implementing a Consistent Hashing Algorithm in TypeScript\", \"The Event Sourcing Design Pattern in TypeScript\", \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\", \"Building Robust Elixir Back-End APIs with Phoenix Contexts\", \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\", \"Mastering Browser Storage in TypeScript\", \"Mastering Rust's `std::env::args_os()`\", \"Building Composable, Scalable, and Reusable Redux Reducers\", \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7OgX0Ps2AYymLiW6mpFs2OPCOQbrz",
  "object": "chat.completion",
  "created": 1686117718,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 813,
   "completion_tokens": 1100,
   "total_tokens": 1913
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: How to Use Generators to Create Infinite Sequences in Python\n\nTags: Python, Generators, Iterators\n\nGenerators are a powerful feature in Python that allow the creation of iterators with a potentially infinite number of elements. They provide a way to create lazy, memory-efficient sequences that can be processed one element at a time, as needed. In this post, we'll explore the basics of generators and use them to create several examples of infinite sequences.\n\n## Introduction to Generators\n\nGenerators are functions that use the `yield` keyword to return a value and then pause the function execution until the next value is requested. When a generator function is called, it returns a generator object that can be used to iterate through the values produced by the generator.\n\n```python\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\ng = my_generator()\nprint(next(g)) # Output: 1\nprint(next(g)) # Output: 2\nprint(next(g)) # Output: 3\n```\n\nIn this example, the `my_generator()` function defines a generator that produces the values 1, 2, and 3. When we call the `next()` function on the generator object `g`, it executes the `my_generator()` function until it reaches the first `yield` statement. It then returns the value `1` and pauses the function execution. The next call to `next(g)` resumes the function execution, which continues until the next `yield` statement is reached. This process continues until there are no more values to yield.\n\n## Infinite Sequences with Generators\n\nOne of the powerful features of generators is that they can be used to produce potentially infinite sequences. Let's take a look at some examples.\n\n### Fibonacci sequence\n\nThe Fibonacci sequence is a series of integers where each number is the sum of the two preceding numbers. By starting with 0 and 1, the first 10 terms will be: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34.\n\nWe can use a generator to create an infinite sequence of Fibonacci numbers:\n\n```python\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nf = fibonacci()\nfor i in range(10):\n    print(next(f)) # Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34\n```\n\nIn this example, we use the `while` loop to generate the next Fibonacci number and yield it using the `yield` statement. We also use tuple unpacking to simplify the code, assigning `a` to 0 and `b` to 1. By the time we reach the tenth iteration of the for loop, the Fibonacci sequence will have produced the first 10 terms.\n\n### Prime numbers\n\nPrime numbers are a fundamental concept in number theory, and there is no known formula to generate them. However, we can use a generator to create an infinite sequence of prime numbers using the Sieve of Eratosthenes algorithm:\n\n```python\ndef primes():\n    numbers = {}\n    n = 2\n    while True:\n        if n not in numbers:\n            yield n\n            numbers[n*n] = [n]\n        else:\n            for p in numbers[n]:\n                numbers.setdefault(p+n,[]).append(p)\n            del numbers[n]\n        n += 1\n\np = primes()\nfor i in range(10):\n    print(next(p)) # Output: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29\n```\n\nIn this example, the `primes()` function uses a dictionary to keep track of the composite numbers, starting with `n=2`. When a prime number is found, it is yielded using the `yield` statement. False composite numbers are marked by adding their factors to the `numbers` dictionary. When the generator is called again, the next prime number is found and yielded, and the `numbers` dictionary is updated. This process continues indefinitely.\n\n### Random numbers\n\nWe can also use a generator to create an infinite sequence of random numbers by using the `random` module:\n\n```python\nimport random\n\ndef random_numbers():\n    while True:\n        yield random.randint(1,100)\n\nr = random_numbers()\nfor i in range(10):\n    print(next(r)) # Output: random numbers between 1 and 100\n```\n\nIn this example, the `random_numbers()` function generates a new random number between 1 and 100 every time it is called using the `randint()` function from the `random` module. By using a generator, we can create an infinite sequence of random numbers that can be used for testing or simulation purposes.\n\n## Conclusion\n\nGenerators are a powerful feature in Python that can be used to create lazy, memory-efficient sequences of potentially infinite length. They allow us to produce elements one at a time, as needed, and are easy to implement using the `yield` keyword. By using generators to create infinite sequences, we can create new and interesting ways to generate data or solve problems that would not have been possible otherwise."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}