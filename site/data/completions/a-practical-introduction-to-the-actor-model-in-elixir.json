{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7M9Bu3fpdNQo3bCWcSlCceccbnqIn",
  "object": "chat.completion",
  "created": 1685512902,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 814,
   "completion_tokens": 808,
   "total_tokens": 1622
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: A Practical Introduction to the Actor Model in Elixir\n\nTags: Elixir, Actor model, Concurrency\n\n## Introduction\n\nThe actor model is a widely used concurrency model that enables the creation of highly concurrent, distributed systems that are resilient to failure. It is based on the concept of actors, which are independent units of computation that communicate with each other by passing messages. Elixir is an excellent language for developing actor-based systems, thanks to its built-in support for concurrency and distribution. In this post, we’ll explore the actor model and build a simple actor-based system using Elixir.\n\n## What is the Actor Model?\n\nThe actor model is a mathematical theory of concurrent computation first introduced by Carl Hewitt in the 1970s. In this model, a computation is represented by a set of independent actors, each of which has its own state and can receive and send messages. Actors communicate only by passing messages, which are queued and processed asynchronously. Actors can create new actors, send messages to actors, and modify their own state in response to incoming messages.\n\nOne key advantage of the actor model is that it enables highly concurrent, distributed systems that are resilient to failure. Because actors are independent units of computation, they can be distributed across multiple machines, and because messages are queued and processed asynchronously, the system can continue to operate even if some actors fail.\n\n## Creating Actors in Elixir\n\nElixir provides built-in support for actors through its concurrency mechanisms. An actor in Elixir is represented by a process, which is a lightweight, independent unit of execution. Processes in Elixir communicate with each other by sending messages via channels, which are built on top of underlying operating system primitives such as sockets and pipes.\n\nTo create an actor in Elixir, we define a module that implements the `GenServer` behaviour. The `GenServer` behaviour provides a set of callback functions that handle incoming messages and manage the actor’s state. Here’s an example module that defines a simple counter actor:\n\n```elixir\ndefmodule Counter do\n  use GenServer\n\n  def start_link(initial_count) do\n    GenServer.start_link(__MODULE__, initial_count)\n  end\n\n  def init(initial_count) do\n    {:ok, initial_count}\n  end\n\n  def handle_cast(:increment, count) do\n    {:noreply, count + 1}\n  end\nend\n```\n\nIn this module, the `start_link` function creates a new instance of the actor and initializes its state with an initial count. The `init` callback function handles the initialization of the actor’s state. The `handle_cast` callback function handles incoming cast messages, which are messages sent to the actor that don’t require a response. In this case, the `handle_cast` function increments the actor’s count by one and returns a new state.\n\n## Sending Messages to Actors\n\nOnce we’ve created an actor in Elixir, we can send messages to it using the `send` function. The `send` function takes two arguments: the process identifier (`pid`) of the actor and the message to send. Here’s an example of sending a message to the counter actor defined earlier:\n\n```elixir\ncounter_pid = Counter.start_link(0)\nsend(counter_pid, :increment)\n```\n\nIn this example, we start a new instance of the counter actor with an initial count of zero and send it an increment message using the `send` function.\n\n## Conclusion\n\nThe actor model is a powerful concurrency model that enables the creation of highly concurrent, distributed systems that are resilient to failure. Elixir provides built-in support for actors through its concurrency mechanisms, making it an ideal language for building actor-based systems. In this post, we’ve explored the basics of the actor model and shown how to create and send messages to actors in Elixir. For more information on the actor model and building actor-based systems with Elixir, be sure to check out the official Elixir documentation and the many excellent resources available online."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}