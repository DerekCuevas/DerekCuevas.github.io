{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\", \"Building Robust Elixir Back-End APIs with Phoenix Contexts\", \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\", \"Mastering Browser Storage in TypeScript\", \"Mastering Rust's `std::env::args_os()`\", \"Building Composable, Scalable, and Reusable Redux Reducers\", \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\", \"The Magic of High-Level Streams\", \"Using Rust's Pinning API for Safe and Performant Async Programming\", \"Building Scalable REST APIs with Node.js and PostgreSQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7OPfvNZlGkYbsmRRkji8Hi7jJ2chA",
  "object": "chat.completion",
  "created": 1686052923,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 813,
   "completion_tokens": 1069,
   "total_tokens": 1882
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: The Event Sourcing Design Pattern in TypeScript\nTags: TypeScript, Design Patterns\n\n## Introduction\n\nEvent Sourcing is a versatile design pattern in which the state of an application is determined by a sequence of events rather than its current state. This pattern is popular among developers building large-scale, distributed, and event-driven systems.\n\nIn this post, we will explore the Event Sourcing pattern and its practical implementation in TypeScript. We will start by discussing the basics of Event Sourcing and its advantages over traditional state-based designs. Then, we will take a look at a sample application that leverages Event Sourcing to store the state of the application. Finally, we will discuss some common use cases of Event Sourcing and strategies to optimize its performance.\n\n## What is Event Sourcing?\n\nEvent Sourcing is an architectural pattern in which the state of an application is stored as a sequence of events. Each event represents a change to the state of the application and is stored in an event log. To determine the current state of the system, the application replays the event log from the initial state.\n\nThe primary advantage of Event Sourcing is that it provides an accurate and detailed history of the changes made to the system. By using Event Sourcing, developers can easily recreate the state of the system at any point in time and better understand the state of the system at different stages of its development. Additionally, Event Sourcing ensures that the state of the system is immutable, meaning that once an event is stored, it cannot be modified or deleted.\n\n## Implementing Event Sourcing in TypeScript\n\nTo implement Event Sourcing in TypeScript, we need to define an event log and a way to replay the events to determine the current state of the system. Let's walk through the implementation of this pattern for a simple bank account application.\n\n### Defining the Event Log\n\nFirst, we define an interface for bank account events. In our implementation, we only need two events: `AccountCreated` and `DepositMade`.\n\n```typescript\ninterface AccountCreated {\n  type: 'AccountCreated',\n  id: string,\n  owner: string,\n  balance: number,\n}\n\ninterface DepositMade {\n  type: 'DepositMade',\n  id: string,\n  amount: number,\n}\n```\n\nNext, we create an event log to store these events. An event log can be as simple as an array of events.\n\n```typescript\ntype EventLog = (AccountCreated | DepositMade)[];\n```\n\n### Replaying the Event Log\n\nNow, we create a function to replay the event log and generate the current state of the system. In our case, this function creates a new account for each `AccountCreated` event and updates the balance for each `DepositMade` event.\n\n```typescript\nfunction calculateBalance(events: EventLog): number {\n  let balance = 0;\n  events.forEach(event => {\n    switch(event.type) {\n      case 'AccountCreated':\n        balance += event.balance;\n        break;\n      case 'DepositMade':\n        balance += event.amount;\n        break;\n    }\n  });\n  return balance;\n}\n```\n\n### Writing to the Event Log\n\nFinally, we create a function to write new events to the event log.\n\n```typescript\nfunction createAccount(events: EventLog, owner: string, initialBalance: number) {\n  const id = uuidv4();\n  const accountCreated: AccountCreated = {\n    type: 'AccountCreated',\n    id,\n    owner,\n    balance: initialBalance\n  };\n  events.push(accountCreated);\n  return id;\n}\n\nfunction deposit(events: EventLog, id: string, amount: number) {\n  const depositMade: DepositMade = {\n    type: 'DepositMade',\n    id,\n    amount\n  };\n  events.push(depositMade);\n}\n```\n\n## Use Cases of Event Sourcing\n\nEvent Sourcing is particularly useful in systems that require a high level of reliability, traceability, and regulatory compliance. Here are some common use cases for Event Sourcing:\n\n- Accounting and financial systems: Event Sourcing provides an immutable and auditable record of financial transactions.\n- Healthcare systems: Event Sourcing provides a detailed and accurate record of medical processes and treatments.\n- E-commerce systems: Event Sourcing provides an accurate and detailed record of user purchases and product inventory.\n\n## Strategies to Optimize Performance\n\nWhile Event Sourcing provides many advantages, it can also be computationally expensive and resource-intensive. Here are some strategies to optimize the performance of Event Sourcing:\n\n- Use a distributed log: A distributed log enables horizontal scalability and fault tolerance by distributing the events across multiple nodes.\n- Use snapshots: Snapshots provide a way to capture the state of the system at a particular point in time, reducing the number of events that need to be replayed.\n- Store events in a binary format: Storing events in a binary format reduces the size of the event log and makes it faster to read and write.\n\n## Conclusion\n\nEvent Sourcing is a powerful design pattern for building event-driven systems. By storing the state of the system as a sequence of events, Event Sourcing provides a detailed and accurate record of the changes made to the system. With TypeScript, it is easy to implement the Event Sourcing pattern and create scalable, reliable, and traceable systems."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}