{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "Base topics for the blog post off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\", \"Securely Storing Secrets in Rust\", \"How to Write High Performance Elm Code with the Help of Web Workers\", \"The Ultimate Guide to Building and Optimizing GraphQL APIs with Node.js\", \"Building High-Performance Reactive Applications with Rust and Tokio\", \"Mastering GraphQL's Execution Phase with Node.js, TypeScript, and TypeGraphQL\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "system",
   "content": "Use computer code snippets to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Come up with an interesting topic for an advanced level reader that is not related to a previous post and output a post following the rules defined."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line in plain text."
  },
  {
   "role": "user",
   "content": "Include a list of 1 to 3 tags on the last line of the post formatted in plain text as a comma separated list, like:\nTags: <tag1>, <tag2>"
  },
  {
   "role": "user",
   "content": "The post should have multiple sections and should be long in length."
  }
 ],
 "completion": {
  "id": "chatcmpl-7JQcGIcODZ8g9Utqv2dibzG3Dcxgp",
  "object": "chat.completion",
  "created": 1684864900,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 769,
   "completion_tokens": 818,
   "total_tokens": 1587
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building High-Performance Web Apps with Rust and WebGPU\nTags: Rust, WebGPU, Web development\n\n# Introduction\n\nWeb Assembly and Rust have become very popular among web developers to develop high-performance applications like video streaming, games, and other computationally intensive tasks. However, Rust comes with very little in-built libraries for web development. In this blog post, we explore a new technology called WebGPU in combination with Rust to build high-performance web applications.\n\n# What is WebGPU?\n\nWebGPU is a new emerging standard for low-level graphics and compute on the web. It is a graphics API that brings the power of modern desktop graphics to the web. It is faster than WebGL and has a simplified programming model. WebGPU is built on top of the underlying hardware acceleration and works on both desktop and mobile devices.\n\n# Building WebGPU apps with Rust\n\nTraditionally, JavaScript was used for web development, but it has limitations in terms of performance and power. Rust is a systems programming language that can be paired with WebAssembly to unlock high performance and low-level control, with features like zero-cost abstractions, low-level memory management, and a focus on performance and safety.\n\nWebGPU is still a very new technology and bindings for Rust are not yet available via the standard WebIDL-based WebGPU API. But there is a Rust library called `wgpu` available on GitHub that provides a Rust-native API for working with WebGPU.\n\nHere is a code sample that shows how to use `wgpu` to create and render a triangle:\n\n```rust\nuse wgpu::{BufferUsage, Color, Device, Queue, RenderPass, SwapChain};\nuse winit::{event::Event, event_loop::ControlFlow, event_loop::EventLoop, window::Window};\n\nasync fn run() -> Result<(), WebGpuError> {\n    // setup code\n    # Ok(())\n}\n\nfn main() {\n    env_logger::init();\n    let event_loop = EventLoop::new();\n    let window = Window::new(&event_loop)?;\n    let instance = wgpu::Instance::new(wgpu::BackendBit::PRIMARY);\n    // ...\n    let mut state = futures::executor::block_on(setup(&window, &instance))?;\n    event_loop.run(move |event, _, control_flow| {\n        *control_flow = ControlFlow::Poll;\n        match event {\n            Event::RedrawRequested(_) => {\n                // rendering code\n            }\n            Event::MainEventsCleared => {\n                window.request_redraw();\n            }\n            Event::WindowEvent { event, .. } => match event {\n                ...\n            }\n            _ => {}\n        }\n    });\n}\n```\n\n# Setting up a Rust and WebGPU project\n\nTo start off, we need to set up our environment. We need to have Rust installed along with the `wasm-pack` crate and WebGPU compatible hardware or a good emulator.\n\nSecondly, we need to create a new Rust package with the following command:\n\n```\ncargo new --lib my-wgpu-project\n```\n\nTo compile our project to WebAssembly, we need to install `wasm-pack`, which is a Rust tool that compiles our Rust code to a wasm module and packages it as an npm package. To install:\n\n```\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n```\n\nWith `wasm-pack` installed and initialized, just run:\n\n```\ncd my-wgpu-project\nwasm-pack init --scope <npm-username>\n```\n\n# Conclusion\n\nIn this post, we have explored the new emerging WebGPU technology and how it can be coupled with Rust to build high-performance and fast web applications. We also looked at how to create a simple triangle using the Rust `wgpu` library and set up a Rust and WebGPU project. The future of WebGPU looks very promising, and with the growing number of libraries that support it, it's an excellent choice for developers who want to achieve maximum performance on the web."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}