{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LmiMjvNmHDICsSiSAXy3IS5N44bu",
  "object": "chat.completion",
  "created": 1685426502,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 826,
   "completion_tokens": 765,
   "total_tokens": 1591
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "JSON Data Validation with Rust's `serde_json` Library\n\nTags: Rust, JSON, Data Validation\n\nJSON is one of the most common data interchange formats used in web APIs, and parsing, serializing, and validating JSON data are commonly required features in most programming languages. In Rust, `serde` is the de facto standard library for working with JSON data, and `serde_json` is a related Rust crate providing additional functions and types for working with JSON data specifically.\n\nIn this post, we'll explore how to use `serde_json` to validate JSON data, ensuring that the incoming JSON meets specific criteria.\n\n## Installing and Importing `serde_json`\n\nFirst, we need to add `serde_json` as a dependency to our project. We can do this by manually editing the `Cargo.toml` file, adding the following:\n\n```toml\nserde_json = \"1.0.37\"\n```\n\nAlternatively, we can use the command line `cargo` tool:\n\n```bash\n$ cargo add serde_json\n```\n\nNext, we'll import the `serde_json` crate:\n\n```rust\nuse serde_json;\n```\n\n## Validating JSON Data\n\n`serde_json` provides various types for representing and validating JSON data. The most commonly used type is `Value`, which represents a JSON value. We can use the `serde_json::Value` type to parse and validate JSON data.\n\nAssume we have the following JSON object:\n\n```json\n{\n  \"name\": \"John Doe\",\n  \"age\": 30,\n  \"isMarried\": false,\n  \"hobbies\": [\n    \"reading\",\n    \"swimming\",\n    \"hiking\"\n  ]\n}\n```\n\nWe want to ensure that this JSON object has the required fields and field types. For this, we can use Rust's `match` statement and the `serde_json::Value` type as follows:\n\n```rust\nlet json_str = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 30,\n      \"isMarried\": false,\n      \"hobbies\": [\n        \"reading\",\n        \"swimming\",\n        \"hiking\"\n      ]\n    }\n\"#;\n\nlet json_value: serde_json::Value = serde_json::from_str(json_str).unwrap();\n\nmatch json_value {\n    serde_json::Value::Object(obj) => {\n        let name = obj.get(\"name\").unwrap().as_str().unwrap();\n        let age = obj.get(\"age\").unwrap().as_u64().unwrap();\n        let is_married = obj.get(\"isMarried\").unwrap().as_bool().unwrap();\n        let hobbies = obj.get(\"hobbies\").unwrap().as_array().unwrap();\n\n        // Do something with the values...\n    },\n    _ => panic!(\"Invalid JSON\"),\n}\n```\n\nIn this example, we first parse the JSON object string using `serde_json::from_str`, which returns a `Result<serde_json::Value, serde_json::Error>` type. We then match the `Value` type to its corresponding variant using Rust's `match` statement.\n\nIf the JSON object is valid, the `serde_json::Value::Object` variant will be matched, and we can extract and validate the required field values using the `as_*` methods provided by `serde_json::Value`.\n\n## Conclusion\n\n`serde_json` is a powerful crate for working with JSON data in Rust, and provides numerous functions and types for parsing, serializing, and validating JSON data. In this post, we explored how to use `serde_json` for validating JSON data, checking that required fields have valid types. By using the `serde_json::Value` type and Rust's pattern matching features, we can parse and validate JSON data in a simple and easy way."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}