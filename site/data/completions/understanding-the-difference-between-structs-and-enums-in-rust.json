{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building a High-Performance and Cost-Effective Video Transcoding System with Rust and FFmpeg\", \"Building a High-Performance Elixir Web Application with Phoenix and Ecto\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\", \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\", \"Building Real-Time, High-Performance Applications with Rust and WebSockets\", \"How to Build a Distributed System with Rust and Apache Pulsar\", \"Advanced TypeScript types: Generics with constraints\", \"Building High-Performance IoT Applications with Rust\", \"Secret Management in Multi-Cloud Kubernetes Environments: A Comprehensive Guide\", \"Building a Fault-Tolerant Distributed System with Rust\", \"Writing High-Performance Networked Applications in Elixir with Erlang Term Storage\", \"Deep Dive into Rust's Ownership and Borrowing System\", \"Exploring Performance Optimization Techniques for Rust Applications\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7LMinjMuL29dka03190HUGsn2WVx6",
  "object": "chat.completion",
  "created": 1685326585,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 850,
   "completion_tokens": 1105,
   "total_tokens": 1955
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Understanding the Difference Between Structs and Enums in Rust\nTags: Rust, Structs, Enums\n\nRust is a powerful programming language that is quickly becoming a popular choice for building high-performance applications. Among its many features, Rust has a unique way of handling data structures, which can be difficult to understand for newcomers to the language. Specifically, the differences between structs and enums can be confusing at first. In this post, we'll take a deep dive into these two data structures and explore their strengths and weaknesses.\n\n## Structs\n\nIn Rust, a `struct` is a data structure that allows you to group multiple values of different types into a single, named object. Here's an example of a struct that represents a `Person`:\n\n```rust\nstruct Person {\n    name: String,\n    age: u32,\n}\n```\n\nIn this example, the `Person` struct has two fields: `name`, which is of type `String`, and `age`, which is of type `u32`. By grouping these values together into a single `Person` object, we can easily pass it around our codebase and use it to represent individuals in our application.\n\nStructs are useful when you need to store a collection of related data together. They provide a way to create custom data types that are specific to your application's needs, allowing you to write clearer, more concise code.\n\n## Enums\n\nWhile structs group related data together, enums are designed to group related values together. An `enum` in Rust is a data structure that allows you to define a type by enumerating its possible values. Here's an example of an enum that represents `Color`:\n\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\n```\n\nIn this example, we define the `Color` enum to have three possible values: `Red`, `Green`, and `Blue`. Each of these values is defined as a separate variant of the enum.\n\nEnums are useful when you have a fixed set of values that a variable can take on. Rather than using a plain variable that can have any value, you can use an enum to limit the possible values to a specific set. This makes your code easier to read and less prone to errors.\n\n## Differences between Structs and Enums\n\nWhile structs and enums may seem similar, there are some key differences between them that are important to understand.\n\n### Accessing Fields\n\nOne of the biggest differences between structs and enums is how you access their fields. In a struct, each field is given a name, and you can access individual fields using dot notation:\n\n```rust\nlet person = Person {\n    name: \"Alice\".to_string(),\n    age: 30,\n};\n\nprintln!(\"Name: {}\", person.name);\nprintln!(\"Age: {}\", person.age);\n```\n\nIn an enum, you can't access its variants' fields in the same way. Instead, you need to use pattern matching to extract the relevant fields:\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -> u32 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            25\n        },\n    }\n}\n```\n\nIn this example, the `Coin::Quarter` variant has an associated value of type `UsState`. When we match on a value of type `Coin`, we use a pattern that includes the `Coin::Quarter` variant, along with its associated value. We bind the `state` variable to the associated value so that we can use it in the function.\n\n### Pattern Matching\n\nSpeaking of pattern matching, it's worth noting that enums are much more powerful when it comes to pattern matching than structs. By defining an enum with multiple variants, you can create complex patterns that match only certain combinations of values.\n\nHere's an example that uses an enum to represent a `Message`:\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nimpl Message {\n    fn call(&self) {\n        // method body would be defined here\n    }\n}\n\nlet msg = Message::ChangeColor(255, 0, 255);\nmsg.call();\n```\n\nIn this example, we define the `Message` enum to have four variants: `Quit`, `Move`, `Write`, and `ChangeColor`. The `Move` variant has two fields of type `i32`, and the `Write` variant has a field of type `String`. We've also defined a method on the `Message` enum that can be called on any of its variants.\n\nWe can create an instance of the `Message` enum using one of its variants, and then call the `call` method on it. This allows us to provide a common interface across all of our message types, making our code more flexible and easier to reason about.\n\n## Conclusion\n\nBoth structs and enums are powerful data structures that can help you write cleaner, more concise code in Rust. By understanding the differences between them, you'll be able to choose the right one for your particular use case, and write better code as a result."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}