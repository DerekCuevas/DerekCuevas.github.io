{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\", \"How to Build a Type-Safe GraphQL Server in Rust\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7MEojzuDpEdIDGUpvYYWdc2OHX0Ic",
  "object": "chat.completion",
  "created": 1685534529,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 813,
   "completion_tokens": 1391,
   "total_tokens": 2204
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "How to Build High-Availability WebSocket Services with Rust and Actix-Web \n\nTags: Rust, Actix-Web, WebSockets\n\nReal-time communication is increasingly becoming more important in modern web applications. As a result, WebSocket, a protocol that provides full-duplex communication with a server over a single TCP connection has become a popular choice for building real-time web applications. WebSocket is the backbone of many real-time communication apps such as chat systems, push notifications, and online gaming.\n\nIn this post, we'll discuss how to build high-availability WebSocket Services with Rust and Actix-Web, a powerful web framework for Rust. By taking advantage of Rust's ownership model, threading strategy, and Actix's asynchronous processing capabilities, we'll be able to build a performant and reliable WebSocket service.\n\n### Prerequisites\n\nBefore we begin, make sure you have the latest version of Rust installed on your system. You can verify this by running:\n\n```rust\n$ rustc --version\n```\n\nYou should have at least version 1.55.0 or higher. If you don't have Rust installed, you can get it from the official Rust website [rust-lang.org](https://www.rust-lang.org/tools/install).\n\n### Creating a New Actix-Web Project\n\nWe'll begin by creating a new Actix-Web project using cargo, Rust's package manager. Open up the command line and navigate to the directory where you want to store your project.\n\n```rust\n$ cargo new --bin actix_websocket\n```\n\nThis command creates a new binary project named `actix_websocket`.\n\nNext, add the Actix-Web dependency to your project by modifying the `Cargo.toml` file to include the following lines:\n\n```rust\n[dependencies]\nactix-web = \"4\"\nactix-rt = \"2\"\n```\n\n### Implementing the WebSocket Service\n\nTo implement a WebSocket service in Actix-Web, we need to create a new WebSocket handler and a WebSocket actor. The WebSocket actor will be responsible for handling incoming and outgoing WebSocket messages, while the WebSocket handler will manage the connection between the WebSocket client and the WebSocket actor.\n\n#### WebSocket Actor\n\nLet's start by creating a new WebSocket actor. An actor is a concurrent object that receives messages and processes them. In Actix-Web, an actor is implemented using the `actix::Actor` trait. \n\nHere's an example of a simple WebSocket actor:\n\n```rust\nuse actix::{Actor, StreamHandler, Context};\nuse actix_web_actors::ws;\n\nstruct MyWebSocketActor;\n\nimpl Actor for MyWebSocketActor {\n    type Context = ws::WebsocketContext<Self>;\n\n    fn started(&mut self, ctx: &mut Self::Context) {\n        println!(\"WebSocket connection established\");\n    }\n}\n\nimpl StreamHandler<Result<ws::Message, ws::ProtocolError>> for MyWebSocketActor {\n    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {\n        match msg {\n            Ok(ws::Message::Ping(msg)) => {\n                ctx.pong(&msg);\n            }\n            Ok(ws::Message::Text(text)) => {\n                ctx.text(text);\n            }\n            Ok(ws::Message::Binary(bin)) => {\n                ctx.binary(bin);\n            }\n            Ok(ws::Message::Close(reason)) => {\n                ctx.close(reason);\n                ctx.stop();\n            }\n            Err(e) => {\n                println!(\"Error: {:?}\", e);\n                ctx.stop();\n            }\n            _ => (),\n        }\n    }\n}\n```\n\nIn this code, we define a new struct `MyWebSocketActor` that implements the `actix::Actor` and `actix_web::StreamHandler` traits. The `Actor` trait requires a type definition of `Context`, which is the `actix_web::WebsocketContext<Self>` type in this case.\n\nIn the `started` method, we print a message to the console to confirm that a WebSocket connection has been established.\n\nIn the `StreamHandler` trait, we match on the incoming WebSocket message types (`Ping`, `Text`, `Binary`, and `Close`). For each message type, we call the appropriate function on the WebSocket context to respond accordingly.\n\n\n#### WebSocket Handler\n\nNow that we have our WebSocket actor implementation, let's create a WebSocket handler that will accept WebSocket connections, manage the connection, and route messages to the WebSocket actor.\n\n```rust\nasync fn ws_handler(req: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {\n    let res = ws::start(MyWebSocketActor {}, &req, stream);\n\n    match res {\n        Ok(ws) => ws,\n        Err(_) => HttpResponse::InternalServerError().finish(),\n    }\n}\n```\n\nIn this code, we define an `async` function `ws_handler` that takes an `HttpRequest` object and an `actix_web::web::Payload` object as parameters. The `Payload` is a `Stream` of data bytes that represent the WebSocket message content.\n\nInside `ws_handler`, we initiate a new WebSocket connection by calling the `ws::start` function and passing in a new instance of `MyWebSocketActor` along with the `HttpRequest` object and the `Payload` stream. If the connection is successful, the `ws` object is returned. Otherwise, we'll return an Internal Server Error response.\n\n### Putting It All Together\n\nNow we have both our WebSocket actor and WebSocket handler implemented, and we can put them together in the main function of our Rust program:\n\n```rust\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    let port = 8000;\n    println!(\"Starting WebSocket server at port {}\", port);\n    HttpServer::new(|| {\n        App::new()\n            .service(web::resource(\"/ws/\").to(ws_handler))\n    })\n    .bind((\"127.0.0.1\", port))?\n    .run()\n    .await\n}\n```\n\nIn the main function, we set the port number to listen for WebSocket connections on. We then pass in our `ws_handler` function to the `web::resource` method to map to the `/ws/` endpoint. Finally, we bind and run the server using the `HttpServer` object.\n\n### Conclusion\n\nActix-Web provides a powerful, yet simple-to-use platform for implementing WebSocket services in Rust. By taking advantage of Rust's ownership model, threading strategy, and Actix's asynchronous processing capabilities, we can build high-performance, reliable, and robust WebSocket services that meet the needs of modern web applications. In this post, we've covered the basics of creating a WebSocket service using Actix-Web, but this is just the beginning. With Actix-Web and Rust, the possibilities are endless."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}