{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"The Event Sourcing Design Pattern in TypeScript\", \"How to Write Fast Python Code\", \"Building a High-Availability Microservice Architecture with Modern C++\", \"How to Build a Realtime Collaborative Spreadsheet Application with Elixir and Phoenix LiveView\", \"Using the Adapter Pattern to Integrate Legacy Code\", \"Building a Highly Scalable and Performant GraphQL API with Sangria\", \"Building Robust Elixir Back-End APIs with Phoenix Contexts\", \"Building real-time collaborative web apps with Operational Transformation\", \"Mastering Clojure's Reducers\", \"How to Use Swift's Result Type for Error Handling\", \"Mastering Rust Ownership Rules and Borrowing Rules for Type-Safe and Performant Programs\", \"Projecting Elixir's Enum Module into Batches\", \"Mastering Browser Storage in TypeScript\", \"Mastering Rust's `std::env::args_os()`\", \"Building Composable, Scalable, and Reusable Redux Reducers\", \"Exploring Rust's `mem::replace()` Function\", \"Advanced TypeScript: Custom Type Guards\", \"Mastering Elixir's GenServer Callbacks\", \"The Magic of High-Level Streams\", \"Using Rust's Pinning API for Safe and Performant Async Programming\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7OVHzG3axN7EQDkvcY3s2fkjKBIyQ",
  "object": "chat.completion",
  "created": 1686074503,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 811,
   "completion_tokens": 1558,
   "total_tokens": 2369
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Implementing a Consistent Hashing Algorithm in TypeScript\n\nTags: TypeScript, Algorithms, Distributed Systems\n\nConsistent hashing is a fundamental algorithm that enables the creation of distributed hash tables with the ability to automatically balance data across nodes in a cluster. The algorithm maps nodes and keys onto a ring such that each node corresponds to one or more points on the ring, and each key belongs to the node that owns the next closest point clockwise on the ring with the addition of virtual nodes that prevent excessively uneven data distribution.\n\nIn this post, we'll implement a consistent hashing algorithm in TypeScript, which is a superset of JavaScript that adds optional types, classes, and modules for building large-scale applications. We'll start by defining the classes and interfaces to represent a node and a hash ring, followed by the implementation of the hash function, the addition and removal of nodes, and finally the mapping of keys to nodes.\n\n## Defining the Node and Ring Classes\n\nTo represent a node, we'll define an interface that has two properties, namely `id` and `address`.\n\n```typescript\ninterface Node {\n  id: number;\n  address: string;\n}\n```\n\nThe `id` property is a numerical identifier that is unique within the cluster, and the `address` property is a string that identifies the node's network location, such as an IP address and port number.\n\nTo represent a hash ring, we'll define a class that has two properties, namely `nodes` and `virtualNodes`, both of which are arrays of nodes.\n\n```typescript\nclass Ring {\n  private nodes: Node[];\n  private virtualNodes: Node[];\n  \n  constructor() {\n    this.nodes = [];\n    this.virtualNodes = [];\n  }\n  \n  // ...\n}\n```\n\nWe initialize both arrays to empty arrays in the constructor and leave the implementation of the hash method, the addition and removal of nodes, and the mapping of keys to nodes for later.\n\n## Implementing the Hash Function\n\nTo map keys onto the ring, we'll use the SHA-1 hash function, which returns a 160-bit digest that we'll treat as a 20-byte array of unsigned integers. We'll then use the first four bytes of the digest as a hash value that we'll treat as a 32-bit unsigned integer.\n\nTo obtain a hash value for a node or a virtual node, we'll concatenate their `id` and `address` properties, compute the SHA-1 hash of the resulting string, and extract the first four bytes of the digest.\n\nThe implementation of the hash function is straightforward using the `crypto` module that is built into Node.js, on which TypeScript is based.\n\n```typescript\nimport { createHash } from 'crypto';\n\nfunction hash(bytes: Uint8Array): number {\n  const digest = createHash('sha1').update(Buffer.from(bytes)).digest();\n  const hashValue = (digest[0] << 24) | (digest[1] << 16) | (digest[2] << 8) | digest[3];\n  return hashValue >>> 0; // treat as 32-bit unsigned integer\n}\n```\n\nIn the `hash` function, we first create a hash object using `createHash('sha1')`, update it with the bytes of the input array using `update(Buffer.from(bytes))`, and compute the digest using `digest()`. We then extract the first four bytes of the digest, shift them left by the appropriate number of bits, and bitwise OR them into a single 32-bit integer. Finally, we treat the integer as an unsigned integer by shifting it right by zero bits.\n\n## Adding and Removing Nodes\n\nTo add a node to the ring, we'll use the `addNode` method, which will add the node to the `nodes` array and construct one or more virtual nodes that have the same `address` property but different `id` properties.\n\n```typescript\naddNode(node: Node, numVirtualNodes = 10) {\n  this.nodes.push(node);\n  \n  for (let i = 0; i < numVirtualNodes; i++) {\n    const vn: Node = { id: i, address: node.address };\n    this.virtualNodes.push(vn);\n  }\n  \n  this.virtualNodes.sort((a, b) => hash(a.id + a.address) - hash(b.id + b.address));\n}\n```\n\nIn the `addNode` method, we first add the node to the `nodes` array using `this.nodes.push(node)`. We then construct `numVirtualNodes` virtual nodes that share the same `address` property as the node but have different `id` properties using a for loop that runs `numVirtualNodes` times. For each iteration of the loop, we create a virtual node object with the current `id` and the same `address`, and add it to the `virtualNodes` array using `this.virtualNodes.push(vn)`.\n\nFinally, we sort the `virtualNodes` array using a comparator function that compares the hash values of each virtual node. We do this to enable efficient key lookup by selecting the node that owns the next closest point clockwise on the ring.\n\nTo remove a node from the ring, we'll use the `removeNode` method, which will remove all nodes and virtual nodes that have the same `address` property as the specified node.\n\n```typescript\nremoveNode(node: Node) {\n  this.nodes = this.nodes.filter(n => n.address !== node.address);\n  this.virtualNodes = this.virtualNodes.filter(vn => vn.address !== node.address);\n}\n```\n\nIn the `removeNode` method, we first remove the nodes that have the same `address` property as the node using `this.nodes.filter(n => n.address !== node.address)`. We then remove the virtual nodes that have the same `address` property as the node using `this.virtualNodes.filter(vn => vn.address !== node.address)`.\n\n## Mapping Keys to Nodes\n\nTo map a key to a node, we'll use the `getNode` method, which will return the node that owns the next closest point clockwise on the ring.\n\n```typescript\ngetNode(key: string): Node {\n  const h = hash(Buffer.from(key));\n  \n  const vn = this.virtualNodes.find(vn => hash(vn.id + vn.address) >= h);\n  \n  return this.nodes[this.virtualNodes.indexOf(vn) % this.nodes.length];\n}\n```\n\nIn the `getNode` method, we first compute the hash value of the key using `hash(Buffer.from(key))`. We then find the first virtual node whose hash value is greater than or equal to the hash value of the key using `this.virtualNodes.find(vn => hash(vn.id + vn.address) >= h)`. We do this by comparing the hash values of the virtual nodes, which are sorted according to their hash values.\n\nWe then obtain the index of the corresponding node in the `nodes` array using `(this.virtualNodes.indexOf(vn) % this.nodes.length)` and return the node object at that index.\n\n## Conclusion\n\nIn this post, we implemented a consistent hashing algorithm in TypeScript, which is a powerful language for building large-scale applications with type safety and modularity. The implementation covered the definitions of the `Node` and `Ring` classes, the SHA-1 hash function, the addition and removal of nodes, and the mapping of keys to nodes.\n\nConsistent hashing is essential for designing distributed systems that can handle large volumes of data and traffic with fault tolerance and dynamic scalability. It is widely used in industry-standard systems such as Cassandra, MongoDB, and Riak, and is a fundamental building block for cloud computing, microservices, and blockchain."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}