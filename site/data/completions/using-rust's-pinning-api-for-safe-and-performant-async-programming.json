{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building Scalable REST APIs with Node.js and PostgreSQL\", \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7MQ7DjaWxOSTGUNpVuImYAfajKk3g",
  "object": "chat.completion",
  "created": 1685577959,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 809,
   "completion_tokens": 848,
   "total_tokens": 1657
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Using Rust's Pinning API for Safe and Performant Async Programming \nTags: Rust, Async Programming, Pinning API\n\nAsynchronous programming, while an incredibly powerful tool, comes with its own set of challenges and pitfalls. Among these challenges is the need to ensure the safety of data across async boundaries. Failure to do so can result in data races, which are notoriously difficult to debug. Rust's `Pin` API is a powerful tool for ensuring that data is safely handled across async boundaries while also being performant. In this article, we'll cover how to use Rust's `Pin` API to safely handle data across async boundaries.\n\n## What is Pinning?\n\nBefore we dive into how to use Rust's `Pin` API, it's important to understand what pinning is. In Rust, pinning refers to the act of taking ownership of an object and ensuring that its memory address doesn't change. This is particularly important in the context of async programming, where data can be moved between threads at any moment. \n\n## The Pin API\n\nThe `Pin` API is a Rust feature that allows you to pin objects to a specific location in memory. This means that the object cannot be moved, even if it's moved across async boundaries. The `Pin` API allows you to create a `Pin` object that wraps your data and ensures that the data is always located at the same memory address. This enables you to take advantage of the performance benefits of async programming without sacrificing safety.\n\nHere's an example of how the `Pin` API works in practice:\n\n```rust\nuse std::pin::Pin;\n\nstruct MyStruct {\n    data: String,\n}\n\nimpl MyStruct {\n    // This function consumes the struct and returns a pinned box\n    fn pin_me(self: Pin<&mut Self>) -> Pin<Box<Self>> {\n        let pinned = Box::pin(self);\n        pinned\n    }\n}\n\nlet my_struct = MyStruct { data: String::from(\"Hello, world!\") };\nlet pinned = my_struct.pin_me();\n```\n\nIn this example, we define a struct called `MyStruct` that contains a `String` field. We then define a function called `pin_me` that consumes a mutable reference to `MyStruct` wrapped in a `Pin`. This function returns a pinned box that contains the `MyStruct` object.\n\n## Using Pin with Async\n\nNow that we understand the basics of the `Pin` API, let's look at how we can use it with async programming. Async code can move data across threads at any moment, which means that we need to ensure that the data is safe to do so. Using `Pin` allows us to ensure that data is always located at the same memory address, regardless of which thread it's on.\n\n```rust\nasync fn my_async_function(mut my_struct: Pin<Box<MyStruct>>) -> String {\n    let data = my_struct.as_mut().data.to_owned();\n    data\n}\n\nasync fn async_main() {\n    let my_struct = MyStruct { data: String::from(\"Hello, world!\") };\n    let pinned = my_struct.pin_me();\n    let data = my_async_function(pinned).await;\n}\n\n#[tokio::main]\nasync fn main() {\n    async_main().await;\n}\n```\n\nIn this example, we define an async function called `my_async_function` that takes a mutable reference to `MyStruct` wrapped in a `Pin` and returns a `String`. We then create an async `async_main` function that creates a `MyStruct` object, pins it using the `pin_me` method, and passes it to `my_async_function` using `await`. Finally, we define a `main` function that runs `async_main` using `tokio::main`.\n\n## Conclusion\n\nIn conclusion, Rust's `Pin` API is a powerful tool for ensuring that data is safely handled across async boundaries while also being performant. By using the `Pin` API, you can ensure that your data is always located at the same memory address, even if it's moved across async boundaries. This enables you to take advantage of the performance benefits of async programming without sacrificing safety."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}