{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"Building High-Performance Web Applications with Rust and WebAssembly\", \"Building Highly Scalable Distributed Systems with Rust and Apache Kafka\", \"Building High-Performance, Real-time Video Streaming Systems with Rust, Tokio, and WebSockets\", \"Writing Efficient and Safe Elixir Code: A Beginner's Guide to OTP Behaviours\", \"Building a Fast and Scalable HTTP Server with Rust's Actix-Web Library\", \"Building Real-Time, High-Performance Applications with Rust and WebSockets\", \"How to Build a Distributed System with Rust and Apache Pulsar\", \"Advanced TypeScript types: Generics with constraints\", \"Building High-Performance IoT Applications with Rust\", \"Secret Management in Multi-Cloud Kubernetes Environments: A Comprehensive Guide\", \"Building a Fault-Tolerant Distributed System with Rust\", \"Writing High-Performance Networked Applications in Elixir with Erlang Term Storage\", \"Building a High-Performance Real-time Video Streaming System with Rust and WebRTC\", \"Deep Dive into Rust's Ownership and Borrowing System\", \"Mastering the Art of Reactive Programming with Elm and RxJS\", \"Exploring Performance Optimization Techniques for Rust Applications\", \"Building a High-Performance, Real-time Stock Trading System with Rust, Actix, and Redis\", \"Building Reliable Distributed Systems with Rust and Raft Consensus Protocol\", \"A Comprehensive Guide to Asynchronous Programming in Swift with Combine\", \"Building High-Performance Web Apps with Rust and WebGPU\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader. Ensure that the topic is not related to a previous post. Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Explain information and details in the post step by step."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7KyC3JL2E1DiNhExvciwuYvUAssOH",
  "object": "chat.completion",
  "created": 1685232299,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 831,
   "completion_tokens": 1138,
   "total_tokens": 1969
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "How to Build a Type-Safe GraphQL Server in Rust\n\nTags: Rust, GraphQL\n\nGraphQL is a popular query language created by Facebook for building APIs that might replace REST as the new standard for building web APIs. Rust is a programming language that is natively designed to provide safety and performance. Combining GraphQL and Rust can give you a type-safe server that performs well and is secure.\n\nIn this post, we'll explore how to build a type-safe GraphQL server in Rust using the code-first approach and the async-graphql library.\n\n### Prerequisites\n\nBefore we start, make sure you have Rust and Cargo installed on your machine. You can do so by running the following command:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n### Creating a New Rust Project\n\nTo create a new Rust project, use the following command:\n\n```\ncargo new graphql-server\n```\n\nThis will create a new directory with the name `graphql-server`, which will contain a basic project scaffold. Next, move into the project directory and add the `async-graphql` library as a dependency by adding the following line to your `Cargo.toml` file:\n\n```toml\n[dependencies]\nasync-graphql = \"2.10.1\"\n```\n\nThis will download and install the `async-graphql` library when you run `cargo build`.\n\n### Defining the Schema\n\nNow we'll define the GraphQL schema for our server. In GraphQL, the schema describes the types and operations that can be performed on those types. To define the schema, create a new file called `schema.rs` in your project's `src` directory.\n\nIn `schema.rs`, define a new struct for the type that you want to expose in your schema. For example, let's define a simple User struct with an ID and a name:\n\n```rust\npub struct User {\n    pub id: UUID,\n    pub name: String,\n}\n```\n\nNow let's define a struct representing our GraphQL schema, along with a Query object that defines the operations that can be performed on our types:\n\n```rust\nuse async_graphql::{Context, Object, Result};\n\npub struct Query;\n\n#[Object]\nimpl Query {\n    async fn users(&self, ctx: &Context<'_>) -> Result<Vec<User>> {\n        // Fetch users from a database or some other source\n        let users = vec![\n            User { id: UUID::new(), name: String::from(\"Alice\") },\n            User { id: UUID::new(), name: String::from(\"Bob\") },\n        ];\n\n        Ok(users)\n    }\n}\n```\n\nIn this example, we define a `users` method on our `Query` object that fetches a list of users and returns them as a vector of `User` objects.\n\n### Starting the Server\n\nNow let's create a Rust HTTP server that can handle GraphQL requests. To do this, we'll use the `async_graphql::http::playground_source` function to create a GraphQL Playground endpoint, which allows us to test our GraphQL API interactively. We can then use the `async_graphql::http::GraphQL` struct to create an endpoint for our GraphQL API that can accept POST requests.\n\nHere's what the code for our server might look like:\n\n```rust\nuse async_graphql::{EmptyMutation, Schema};\nuse async_graphql::http::{playground_source, GraphQLPlaygroundConfig};\nuse tide::{http::mime, Body, Request, Response, Server};\n\nmod schema;\n\n#[async_std::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    let schema = Schema::new(\n        schema::Query,\n        EmptyMutation,\n    );\n\n    let mut app = Server::new();\n\n    let graphql_endpoint = async_graphql_tide::endpoint(schema);\n    app.at(\"/graphql\").post(graphql_endpoint);\n\n    let graphql_playground = Body::from(playground_source(\n        GraphQLPlaygroundConfig::new(\"/graphql\"))).with_mime(mime::HTML);\n    app.at(\"/\").get(move |_| async move { Ok(Response::new(graphql_playground.clone())) });\n\n    app.listen(\"localhost:8080\").await?;\n\n    Ok(())\n}\n```\n\nThis code creates a new `Schema` object with our `Query` type, an empty `Mutation` type, and any other types that we've defined in our schema. It then creates a new `tide::Server` object and registers two endpoints: one for serving the GraphQL Playground and one for accepting GraphQL requests.\n\nTo run the server, run the following command in your terminal:\n\n```\ncargo run\n```\n\n### Querying the Server\n\nNow that our server is up and running, we can query it using the GraphQL Playground interface. Open your browser and navigate to `http://localhost:8080`. You should see the GraphQL Playground interface, which allows you to compose and execute GraphQL queries against your server.\n\nTo test the server, let's run a simple query that fetches all of the users in our system:\n\n```graphql\n{\n  users {\n    id\n    name\n  }\n}\n```\n\nWhen you run this query, you should see a JSON response containing the ID and name of each user.\n\n### Conclusion\n\nIn this post, we've explored how to build a type-safe GraphQL server in Rust using the `async-graphql` library. By defining a GraphQL schema using Rust code, we can take advantage of Rust's safety and performance while building a modern, type-safe web API."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}