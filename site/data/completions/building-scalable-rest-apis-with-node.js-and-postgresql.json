{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "New topics for the blog should be based off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build High-Availability WebSocket Services with Rust and Actix-Web\", \"A Practical Introduction to the Actor Model in Elixir\", \"Mastering JavaScript's Array.concat() Method for High-Performance and Scalable Code\", \"Building High-Performance, Real-time Message-Based Applications with Rust and Pulsar\", \"The Art of Error Handling in Node.js\", \"JSON Data Validation with Rust's `serde_json` Library\", \"Exploring the Rust Standard Library's VecDeque\", \"Advanced TypeScript Types: Mapped Types\", \"Advanced Swift: Using Protocol Composition to Achieve Type-Safe, Modular Code\", \"Advanced Elixir: Scenic, a Great UI Library\", \"Building Robust Applications with Function Composition in Clojure\", \"Weird Rust Features\", \"Understanding Closure in JavaScript\", \"Advanced TypeScript types: Conditional Types\", \"To Mutable or Immutable: Exploring Rust's Memory Ownership Model\", \"The Power of Functional Programming in Swift\", \"Understanding the Difference Between Structs and Enums in Rust\", \"Building Ultra-Fast Web Applications with Rust's Actix-Web Library\", \"Mastering the Art of Asynchronous Programming with Rust Futures\", \"Building a High-Performance and Cost-Effective Video Streaming Platform with Rust and AWS Elemental MediaStore\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, to the point, informative, and focused on detailed technical information."
  },
  {
   "role": "user",
   "content": "Come up with an advanced topic for an expert level reader that is about a particular single feature, fact, pattern, paradigm, convention, theory, framework, library, practical example, or best practice."
  },
  {
   "role": "user",
   "content": "The topic should not be related to a previous post."
  },
  {
   "role": "user",
   "content": "Write a post about the topic following the rules defined."
  },
  {
   "role": "user",
   "content": "Use computer code snippets (in the relevant programming language) in order to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line."
  },
  {
   "role": "user",
   "content": "Include one to three tags for the post on the second line formatted as a comma separated list, for example: \"Tags: <tag1>, <tag2>\"."
  },
  {
   "role": "user",
   "content": "Do not include images in the post."
  },
  {
   "role": "user",
   "content": "The post should be multiple sections in length and come to a complete finish."
  }
 ],
 "completion": {
  "id": "chatcmpl-7MKQYyjQYxFHkmPLq8BkAtl7hlyt6",
  "object": "chat.completion",
  "created": 1685556094,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 818,
   "completion_tokens": 1341,
   "total_tokens": 2159
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Building Scalable REST APIs with Node.js and PostgreSQL\n\nTags: Node.js, PostgreSQL, REST APIs\n\nNode.js is an extremely popular platform for building REST APIs. Its non-blocking I/O model and asynchronous event-driven architecture make it ideal for developing high-performing, scalable network applications. In this post, we'll take a deep dive into building scalable REST APIs with Node.js and PostgreSQL.\n\n## Prerequisites\n\nBefore we begin, you'll need to have the following installed:\n\n- Node.js (version 12 or later)\n- PostgreSQL (version 10 or later)\n\nYou should also have a basic understanding of Node.js and how to use it to build REST APIs.\n\n## Setting up the Project\n\nLet's start by creating a new Node.js project and installing the necessary dependencies:\n\n```bash\n# Create a new folder for the project\nmkdir scalable-rest-apis\ncd scalable-rest-apis\n\n# Initialize a new Node.js project\nnpm init\n\n# Install the necessary dependencies\nnpm install express pg\n```\n\nWe're using `express` as our web framework and `pg` as our PostgreSQL database driver.\n\nNow that we have our project set up, let's create a new file called `index.js` and add the following code:\n\n```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\n\n// Initialize express app and database connection pool\nconst app = express();\nconst pool = new Pool({\n  user: 'postgres',\n  host: 'localhost',\n  database: 'mydb',\n  password: 'password',\n  port: 5432,\n});\n\n// Define routes\napp.get('/users', async (req, res) => {\n  const { rows } = await pool.query('SELECT * FROM users');\n  res.json(rows);\n});\n\n// Start the server\napp.listen(8000, () => {\n  console.log('Server is listening on port 8000');\n});\n```\n\nThis code initializes an express app and a database connection pool with the appropriate configuration options. We then define a single route for getting all users from the database.\n\n## Creating the Database\n\nNext, we need to create our PostgreSQL database and add a `users` table. Run the following SQL commands in a PostgreSQL client:\n\n```sql\nCREATE DATABASE mydb;\n\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  name TEXT\n);\n```\n\nThis creates a new database called `mydb` and a `users` table with an `id` column and a `name` column.\n\n## Writing Routes\n\nWe now have the basic infrastructure set up for our REST API. Let's add some more routes for creating, updating, and deleting users.\n\n```javascript\n// Create a user\napp.post('/users', async (req, res) => {\n  const { name } = req.body;\n  const { rows } = await pool.query('INSERT INTO users (name) VALUES ($1) RETURNING *', [name]);\n  res.json(rows[0]);\n});\n\n// Update a user\napp.put('/users/:id', async (req, res) => {\n  const { id } = req.params;\n  const { name } = req.body;\n  const { rows } = await pool.query('UPDATE users SET name = $1 WHERE id = $2 RETURNING *', [name, id]);\n\n  if (rows.length === 0) {\n    res.status(404).send('User not found');\n  } else {\n    res.json(rows[0]);\n  }\n});\n\n// Delete a user\napp.delete('/users/:id', async (req, res) => {\n  const { id } = req.params;\n  const { rows } = await pool.query('DELETE FROM users WHERE id = $1 RETURNING *', [id]);\n\n  if (rows.length === 0) {\n    res.status(404).send('User not found');\n  } else {\n    res.sendStatus(204);\n  }\n});\n```\n\nThese routes allow us to create, update, and delete users in the database using the HTTP POST, PUT, and DELETE methods, respectively.\n\n## Adding Input Validation\n\nOur REST API now has routes for creating, updating, and deleting users, but we still need to add input validation to ensure that the requests contain valid data. Let's use the popular `joi` library for this purpose. First, install the `joi` library:\n\n```bash\nnpm install joi\n```\n\nThen, add input validation to our `POST` and `PUT` routes:\n\n```javascript\nconst Joi = require('joi');\n\n// Create a user\napp.post('/users', async (req, res) => {\n  const { error } = Joi.object({\n    name: Joi.string().min(3).max(30).required(),\n  }).validate(req.body);\n\n  if (error) {\n    res.status(400).send(error.details[0].message);\n    return;\n  }\n\n  const { name } = req.body;\n  const { rows } = await pool.query('INSERT INTO users (name) VALUES ($1) RETURNING *', [name]);\n  res.json(rows[0]);\n});\n\n// Update a user\napp.put('/users/:id', async (req, res) => {\n  const { error } = Joi.object({\n    name: Joi.string().min(3).max(30).required(),\n  }).validate(req.body);\n\n  if (error) {\n    res.status(400).send(error.details[0].message);\n    return;\n  }\n\n  const { id } = req.params;\n  const { name } = req.body;\n  const { rows } = await pool.query('UPDATE users SET name = $1 WHERE id = $2 RETURNING *', [name, id]);\n\n  if (rows.length === 0) {\n    res.status(404).send('User not found');\n  } else {\n    res.json(rows[0]);\n  }\n});\n```\n\nWe added a validation schema using the `Joi.object()` method, which specifies that the `name` field is required and must be between 3 and 30 characters long. We then validate the request body using this schema and send a `400 Bad Request` response if the validation fails.\n\n## Conclusion\n\nIn this post, we've covered how to build scalable REST APIs with Node.js and PostgreSQL. We created a basic infrastructure for our REST API, with support for creating, updating, and deleting users. We then added input validation using the `joi` library. You should now be able to apply these concepts to build your own scalable REST APIs."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}