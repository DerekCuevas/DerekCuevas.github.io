{
 "prompt": [
  {
   "role": "system",
   "content": "You are the author of a personal technical blog about software engineering and computer science subjects."
  },
  {
   "role": "system",
   "content": "Write as though you are the author of this resume:\n+++\ntitle = \"Résumé\"\ndescription = \"Derek Cuevas's Résumé\"\ndate = \"2023-05-20\"\nauthor = \"Derek Cuevas\"\n+++\n\nSenior Software Engineering Tech Lead with 8 years of professional experience building full stack applications and highly available, performance critical, realtime systems and services.\n\n## Programming Languages\n\n- Rust\n- TypeScript\n- Elm\n- Swift\n- Elixir\n- Clojure\n- SQL\n- HTML & CSS\n\n## Technologies, Skills, and Interests\n\n- **Paradigms:** Functional Programming, Realtime Systems, Distributed Systems, Data Structures, Algorithms\n- **Rust:** Futures, Async/Await, Tokio, Hyper, Actix, MPSC Channels, Serde\n- **Protocols:** HTTP, GraphQL, WebSockets, TCP, HLS, DASH, ZMQ, Flatbuffers, Protobuf, MsgPack, JSON\n- **Services:** Node.js, AWS (S3, EC2, SQS, ect.), PostgreSQL, Redis, Pulsar, RabbitMQ\n- **Frameworks:** React, React Native, Redux, RxJs, SwiftUI\n- **Tooling:** Git, Vim, Docker, Bash\n"
  },
  {
   "role": "system",
   "content": "Base topics for the blog post off of the technical skills, experience, and interests presented in the resume."
  },
  {
   "role": "system",
   "content": "Your previous 20 posts include: \"How to Build a Real-time Chat Application: A Comprehensive Tutorial with Node.js, WebSocket, and Redis\", \"How to Use Redis for Fast and Scalable Caching in Node.js\", \"RESTful API Design Best Practices: A Comprehensive Guide to Creating Robust and Scalable APIs\", \"A Beginner's Guide to Functional Programming in JavaScript\", \"A Deep Dive into Rust's Unsafe Operations\", \"Building High-Performance Parallel Applications with Rust's Rayon Library\", \"Exploring React Native Animations: An Advanced Guide\", \"How to Optimize React Native Performance\", \"Building Realtime Web Apps with Clojure and WebSockets\", \"How to Use Clojure to Build a High-Performance, Distributed System\", \"Building a High-Performance Streaming System with Rust\", \"A Comprehensive Guide to Building High-Performance, Distributed Systems with Elixir\", \"Building a High-Performance Real-Time Analytics Dashboard with Rust and PostgreSQL\", \"Writing Rust Macros: A Comprehensive Guide\", \"Efficient Pattern Matching with Rust\""
  },
  {
   "role": "system",
   "content": "Your writing style is concise, informative, and focused on detailed technical information."
  },
  {
   "role": "system",
   "content": "Use computer code snippets to illustrate the information presented."
  },
  {
   "role": "user",
   "content": "Come up with an interesting topic for an advanced level reader that is not related to a previous post and output a post following the rules defined."
  },
  {
   "role": "user",
   "content": "Format the body of the post in the markdown markup language."
  },
  {
   "role": "user",
   "content": "Include the title of the post on the first line in plain text."
  },
  {
   "role": "user",
   "content": "Include a list of 1 to 3 tags on the last line of the post formatted in plain text as a comma separated list, like:\nTags: <tag1>, <tag2>"
  },
  {
   "role": "user",
   "content": "The post should have multiple sections and should be long in length."
  }
 ],
 "completion": {
  "id": "chatcmpl-7IyWwMiqxZfBe5OVzOekki4jHWJOs",
  "object": "chat.completion",
  "created": 1684756938,
  "model": "gpt-3.5-turbo-0301",
  "usage": {
   "prompt_tokens": 700,
   "completion_tokens": 1693,
   "total_tokens": 2393
  },
  "choices": [
   {
    "message": {
     "role": "assistant",
     "content": "Title: Securely Storing Secrets in Rust\n\nSecurity, Rust, Cryptography\n\n---\n\nAs software engineers, we often have to handle confidential information such as passwords, access tokens, and API keys, which should not be hardcoded in our applications. Leaking even small pieces of this sensitive data can have severe consequences, including financial loss, reputational damage, and legal issues. Therefore, it's crucial to properly secure this information to prevent it from falling into the wrong hands.\n\nIn this post, we'll explore some of the methods we can use to securely store secrets in our Rust applications. We'll begin by discussing why we should avoid hardcoding secrets, then examine some conventional approaches to storing them. Afterward, we'll take a deep dive into Rust's crypto libraries and explore how to use them to encrypt and decrypt secrets properly.\n\n## Why You Shouldn't Hardcode Secrets\n\nHardcoding your secrets directly in your source code is a terrible idea. Consider the following example:\n\n```rust\nlet password = \"mysecretpassword\";\n```\n\nIn this example, the password is hardcoded into the application, meaning it's visible to anyone who has access to the source code repository, which could include potential attackers or malicious insiders. Even if the application is compiled into a binary, the password may still be visible in the binary file as plaintext. Additionally, when you need to update the password, you must modify the source code and recompile the application, which defeats the purpose of keeping secrets confidential.\n\n## Conventional Approaches to Storing Secrets\n\nBefore we dive into Rust's cryptography libraries, let's first examine some conventional methods of storing secrets.\n\n### Environment Variables\n\nOne common approach to storing secrets is to use environment variables. The primary benefit of this approach is that it keeps the secrets outside of your source code, making it easy to change them without modifying the application's code. For example, you might store a password as an environment variable like this:\n\n```bash\nexport PASSWORD=mysecretpassword\n```\n\nIn Rust, you can retrieve this value using the `std::env` module:\n\n```rust\nlet password = std::env::var(\"PASSWORD\").unwrap();\n```\n\nThis approach works well for simple secrets, but it has some drawbacks. First, it requires additional setup outside of the application. Second, it's not entirely foolproof, as `env` variables may be visible to other applications running on the same machine.\n\n### Configuration Files\n\nAnother alternative to environment variables is to use configuration files. A configuration file is external to the application and can have its permissions set to be only visible to the application owner. However, like environment variables, configuration files can't provide complete security against data breaches. Secrets stored in configuration files can be exposed if the file is not correctly secured.\n\n```rust\n// Example of reading values from a configuration file with serde\n\n#[derive(Debug, Deserialize)]\nstruct Config {\n    username: String,\n    password: String,\n    token: String,\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let content = std::fs::read_to_string(\"config.toml\")?;\n    let config: Config = toml::from_str(&content)?;\n    Ok(())\n}\n```\n\n## Cryptography Libraries\n\nNow that we've discussed some conventional approaches, let's explore Rust's cryptography libraries. Rust has several cryptography libraries that provide various levels of security and functionality. In the following sections, we'll look at two of them: Sodiumoxide and RustCrypto.\n\n### Sodiumoxide\n\nSodiumoxide is an easy-to-use library for Rust that provides cryptographic primitives and utilities. Sodiumoxide offers several cryptographic primitives, including symmetric-key cryptography (such as key generation, encryption, and decryption) and public-key cryptography (such as signing operations). In our example, we'll use sodiumoxide to encrypt and decrypt a password.\n\n```rust\nuse sodiumoxide::{\n    crypto::{\n        pwhash::{self, Salt},\n        secretbox::{self, Key},\n    },\n    randombytes,\n};\n\n// Generate a random salt\nlet salt = Salt::new(&randombytes::randombytes(16));\n\n// Derive a key from a password and salt\nlet password = \"mysecretpassword\";\nlet mut derived_key = Key([0; secretbox::KEYBYTES]);\npwhash::derive_key(\n    &mut derived_key,\n    password.as_bytes(),\n    &salt,\n    pwhash::OPSLIMIT_INTERACTIVE,\n    pwhash::MEMLIMIT_INTERACTIVE,\n).unwrap();\n\n// Encrypt a secret using the derived key\nlet secret = \"mysecret\";\nlet nonce = secretbox::Nonce::from_slice(&randombytes::randombytes(24)).unwrap();\nlet ciphertext = secretbox::seal(\n    secret.as_bytes(),\n    &nonce,\n    &secretbox::Key::from_slice(&derived_key.0).unwrap(),\n);\n\n// Decrypt the encrypted secret using the derived key\nlet plaintext = secretbox::open(\n    &ciphertext,\n    &nonce,\n    &secretbox::Key::from_slice(&derived_key.0).unwrap(),\n).unwrap();\nlet decrypted_secret = std::str::from_utf8(&plaintext).unwrap();\nassert_eq!(secret, decrypted_secret);\n```\n\nHere, we use sodiumoxide to generate a salt, derive a key from the password and salt, encrypt a secret, and decrypt the encrypted secret using the derived key.\n\n### RustCrypto\n\nRustCrypto is another cryptography library for Rust. RustCrypto offers cryptographic primitives such as symmetric-key cryptography (including block ciphers, stream ciphers, and authenticated encryption with associated data) and hashing.\n\n```rust\nuse aes::Aes256;\nuse block_modes::{BlockMode, Cbc};\nuse block_padding::Pkcs7;\nuse rand::rngs::OsRng;\nuse rand::RngCore;\n\ntype Aes256Cbc = Cbc<Aes256, Pkcs7>;\n\nfn encrypt(secret: &[u8], key: &[u8], iv: &[u8]) -> Vec<u8> {\n    let cipher = Aes256Cbc::new_from_slices(key, iv).unwrap();\n    let mut encrypted = secret.to_vec();\n    let padding_required = cipher.block_size() - (secret.len() % cipher.block_size());\n    let padding_vec = vec![padding_required as u8; padding_required];\n    encrypted.extend_from_slice(&padding_vec);\n\n    let mut ciphertext = vec![0u8; encrypted.len()];\n    cipher.encrypt(&mut encrypted, &mut ciphertext);\n\n    ciphertext\n}\n\nfn decrypt(ciphertext: &[u8], key: &[u8], iv: &[u8]) -> Vec<u8> {\n    let cipher = Aes256Cbc::new_from_slices(key, iv).unwrap();\n\n    let mut plaintext = vec![0u8; ciphertext.len()];\n    let mut decrypted = vec![0u8; ciphertext.len()];\n    cipher.decrypt(ciphertext, &mut decrypted).unwrap();\n\n    let padding_len = decrypted[decrypted.len() - 1] as usize;\n    plaintext.extend_from_slice(&decrypted[..decrypted.len() - padding_len]);\n\n    plaintext\n}\n\nlet password = \"mysecretpassword\";\nlet key = [0u8; 32];\nlet mut iv = [0u8; 16];\nOsRng.fill_bytes(&mut iv);\n\nlet secret = \"mysecret\".as_bytes();\nlet ciphertext = encrypt(secret, &key, &iv);\nlet plaintext = decrypt(&ciphertext, &key, &iv);\nassert_eq!(plaintext, secret);\n```\n\nIn this example, we use RustCrypto to define an encryption and decryption function that uses AES-256 in CBC mode. We generate a random initialization vector and a 256-bit key. Then, we encrypt and decrypt a secret using the defined functions.\n\n## Conclusion\n\nSecuring secrets is a crucial aspect of building software applications. Rust provides several cryptography libraries, such as Sodiumoxide and RustCrypto, that help us securely store secrets.\n\nUsing environment variables and configuration files are conventional ways of storing secrets; however, cryptography libraries offer a more secure approach.\n\nIn this post, we explored how to securely store secrets using cryptography in Rust. We examined some conventional methods, then dove into the Rust cryptography libraries, exploring examples of how to encrypt and decrypt secrets."
    },
    "finish_reason": "stop",
    "index": 0
   }
  ]
 }
}