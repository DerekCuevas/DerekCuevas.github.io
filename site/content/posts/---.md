---
title: "---"
date: 2023-09-16T01:24:35.235Z
tags: ["rust","webassembly","javascript"]
authors: ["gpt-4"]
---

# Mastering Rust's WASM Bindgen: Bridging Rust and JavaScript 



## Introduction

With the advent of WASM, or WebAssembly, developers can now leverage languages like Rust in the web environment, which was traditionally dominated by JavaScript. One essential tool in this venture is `wasm-bindgen`, a library, and a tool to facilitate high-level interactions between Rust and JavaScript.

In this post, we'll deep dive into `wasm-bindgen`, learning how to use it to interact seamlessly between Rust and JavaScript, and vice versa.


## Setting Up `wasm-bindgen`

Firstly, add `wasm-bindgen` to your Rust project's dependencies. In your `Cargo.toml`, add:

```toml
[dependencies]
wasm-bindgen = "0.2"
```

Additionally, install the CLI tool which is required to generate the required bindings after the Rust code is compiled to WASM:

```
cargo install wasm-pack
```


## Creating Rust Functions Accessible in JavaScript

With the setup complete, let's create a Rust function that we can call from JavaScript. In the `lib.rs` file of your project, add the following:

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    return format!("Hello, {}!", name);
}
```

Here, the `#[wasm_bindgen]` attribute signals to the `wasm-bindgen` tool that the following item should be accessible to JavaScript.


## Generating WASM Bindings and Using Them in JavaScript

Now, build your project by running:

```
wasm-pack build --target web
```

This command compiles your Rust code into WASM and generates the corresponding JavaScript bindings.

The `--target web` flag specifies that we want to use this in a web environment.

You can now import these Rust functions as JavaScript modules. Assuming the `wasm-pack build` command generated a `pkg` directory, you can import the `greet` function in your JavaScript code like this:

```javascript
import init, { greet } from './pkg/your_project.js';

async function run() {
    await init();
    console.log(greet('Rustacean'));
}

run();
```

This will asynchronously initialize the WASM module and then log 'Hello, Rustacean!' to the console. 


## Returning Complex Data Structures

Returning simple data types like integer, string, and float are straightforward in `wasm-bindgen`. But, let's have a look at returning complex types such as structs:

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct User {
    name: String,
    age: u8,
}

#[wasm_bindgen]
impl User {
    #[wasm_bindgen(constructor)]
    pub fn new(name: String, age: u8) -> User {
        User { name, age }
    }

    #[wasm_bindgen(getter)]
    pub fn name(&self) -> String {
        self.name.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn age(&self) -> u8 {
        self.age
    }
}
```

Here, the `User` struct and its methods are also annotated with `#[wasm_bindgen]`, making them accessible in JavaScript. 

The corresponding JavaScript code to create a new `User` object and accessing its properties would be:

```javascript
import init, { User } from './pkg/your_project.js';

async function run() {
    await init();
    const user = new User('Alice', 30);
    console.log(user.name);  // Outputs: 'Alice'
    console.log(user.age);  // Outputs: 30
}

run();
```


## Conclusion

`wasm-bindgen` truly makes it convenient to call Rust code from JavaScript, and this is just the tip of the iceberg. Rust can potentially be used in web projects to run CPU-intensive tasks faster, writing safer code due to its borrow-checker, and leveraging ecosystem libraries. Happy Rusting!
